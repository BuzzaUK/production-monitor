#include <WiFi.h>
#include <WebServer.h>
#include <SPIFFS.h>
#include <Preferences.h>
#include <time.h>
#include <ctype.h>

// Forward declarations
String htmlDashboard();
String htmlAnalytics();
String htmlAnalyticsCompare();
String htmlConfig();
void sendHtmlEventsPage();
String wifiConfigHTML();
String htmlAssetDetail(uint8_t idx);
void handleConfigPost();
void handleClearLog();
void handleExportLog();
void handleApiSummary();
void handleApiEvents();
void handleApiConfig();
void handleApiNote();
void handleNotFound();
void updateEventNote(String date, String time, String assetName, String note, String reason);
void logEvent(uint8_t assetIdx, bool machineIsRunning, time_t now, const char* customNote = nullptr, unsigned long runDuration = 0, unsigned long stopDuration = 0);
void logSystemEvent(bool systemIsStarting, time_t now, const char* triggerAssetNameOrReason); // Added
void handleWiFiReconfigurePost();
void setupTime();
String urlEncode(const String& str);
String urlDecode(const String& str);

// USER CONFIGURATION
#define MAX_ASSETS 10
#define LOG_FILENAME "/log.csv"
const char* DEFAULT_DOWNTIME_REASONS[5] = {
  "Maintenance", "Material Shortage", "Operator Break", "Equipment Failure", "Changeover"
};

// --- Added Monitoring Mode Defines ---
#define MONITORING_MODE_PARALLEL 0
#define MONITORING_MODE_SERIAL 1
// --- End Added Defines ---

struct AssetConfig { char name[32]; uint8_t pin; };
struct Config {
  uint8_t assetCount;
  uint16_t maxEvents;
  AssetConfig assets[MAX_ASSETS];
  char downtimeReasons[5][32];
  int tzOffset;
  int longStopThresholdSec;
  int monitoringMode; // <<< ADDED for monitoring mode
} config;

struct AssetState {
  bool lastState; // true if pin is HIGH (STOPPED for INPUT_PULLUP), false if pin is LOW (RUNNING)
  time_t lastChangeTime;
  unsigned long runningTime;  // Cumulative for current session/since last log clear
  unsigned long stoppedTime;  // Cumulative for current session/since last log clear
  unsigned long sessionStart; // Timestamp of when current session stats started (e.g. boot or log clear)
  unsigned long lastEventTime; // Timestamp of the last logged event for this asset
  uint32_t runCount;      // Number of times asset has started
  uint32_t stopCount;     // Number of times asset has stopped
  unsigned long lastRunDuration;  // Duration of the most recent run period
  unsigned long lastStopDuration; // Duration of the most recent stop period
};

// Event struct (no changes from your original)
struct Event {
  time_t timestamp; char assetName[32]; char eventType[8]; int state;
  float availability; float runtime; float downtime; float mtbf; float mttr;
  unsigned int stops; char runDuration[8]; char stopDuration[8]; char note[64];
  Event() { /* constructor */
    timestamp = 0; assetName[0] = '\0'; eventType[0] = '\0'; state = 0;
    availability = 0; runtime = 0; downtime = 0; mtbf = 0; mttr = 0;
    stops = 0; runDuration[0] = '\0'; stopDuration[0] = '\0'; note[0] = '\0';
  }
};

// V21.ino (Continued - Chunk 2)

WebServer server(80);
Preferences prefs; // Global prefs object (note: load/saveConfig use local ones)
AssetState assetStates[MAX_ASSETS];
char wifi_ssid[33] = "";
char wifi_pass[65] = "";

// --- Global Variables for System State (Serial Mode) ---
bool g_isSystemSerialDown = false;          // True if the overall system (in serial mode) is considered down
char g_serialSystemTriggerAssetName[32] = ""; // Name of the asset that triggered the system downtime
time_t g_systemLastStateChangeTime = 0;     // Timestamp of the last system-wide state change
unsigned long g_systemTotalRunningTimeSecs = 0; // Cumulative system running time
unsigned long g_systemTotalStoppedTimeSecs = 0; // Cumulative system stopped time
uint32_t g_systemStopCount = 0;             // Number of system-wide stop events
bool g_systemStateInitialized = false;      // Flag to check if system state has been initialized
// --- End System State Globals ---

// V21.ino (Continued - Chunk 3: WiFi Functions - No changes from your V21)

String wifiConfigHTML() {
  String html = "<!DOCTYPE html><html><head><title>WiFi Setup</title>"
                "<meta charset='UTF-8'>"
                "<style>"
                "body { font-family: Arial; margin: 2em; background: #f6f8fa; }"
                "form { background: #fff; padding: 2em; border-radius: 8px; box-shadow: 0 0 8px #ccc; max-width: 400px; margin:auto;}"
                "h1 { color: #0366d6; }"
                "label { display:block; margin-top:1em; }"
                "input[type=text], input[type=password] { width:100%; padding:0.5em; box-sizing: border-box; }"
                "input[type=submit] { background: #0366d6; color: #fff; border: none; padding: 0.7em 1.5em; margin-top:1em; border-radius: 4px; cursor:pointer;}"
                "input[type=submit]:hover { background: #0356b6; }"
                ".note { color: #888; font-size: 0.95em; margin: 1em 0; }"
                "</style>"
                "</head><body>"
                "<form method='POST' action='/wifi_save_config'>"
                "<h1>WiFi Setup</h1>"
                "<label>SSID:</label>"
                "<input type='text' name='ssid' maxlength='32' required value='";
  html += wifi_ssid;
  html += "'>"
          "<label>Password:</label>"
          "<input type='password' name='password' maxlength='64' value='";
  html += wifi_pass;
  html += "'>"
          "<div class='note'>Enter your WiFi details above. Device will reboot after saving.</div>"
          "<input type='submit' value='Save & Reboot'>"
          "</form>"
          "</body></html>";
  return html;
}

void handleWifiConfigPost() {
  if (server.hasArg("ssid")) {
    String ssid_arg = server.arg("ssid");
    String pass_arg = server.arg("password");
    strncpy(wifi_ssid, ssid_arg.c_str(), 32);
    wifi_ssid[32] = '\0';
    strncpy(wifi_pass, pass_arg.c_str(), 64);
    wifi_pass[64] = '\0';
    
    // Use the global prefs object for saving WiFi credentials
    prefs.begin("assetmon", false); // Ensure it's open for write
    prefs.putString("ssid", wifi_ssid);
    prefs.putString("pass", wifi_pass);
    prefs.end();

    server.send(200, "text/html", "<h2>Saved! Rebooting...</h2><meta http-equiv='refresh' content='3;url=/' />");
    delay(1000);
    ESP.restart();
  } else {
    server.send(400, "text/plain", "Missing WiFi credentials");
  }
}

void startConfigPortal() {
  WiFi.disconnect(true); // Ensure disconnection from any previous network
  WiFi.mode(WIFI_AP);
  WiFi.softAP("AssetMonitor_Config", "setpassword"); // Consider a more unique default password or make it configurable
  Serial.print("Config Portal Started. Connect to AP 'AssetMonitor_Config', IP: ");
  Serial.println(WiFi.softAPIP());
  server.on("/", HTTP_GET, [](){ server.send(200, "text/html", wifiConfigHTML()); });
  server.on("/wifi_save_config", HTTP_POST, handleWifiConfigPost);
  // Add a catch-all for other paths in AP mode to redirect to config
  server.onNotFound([](){ server.send(200, "text/html", wifiConfigHTML()); }); 
  server.begin();
  while (true) { server.handleClient(); delay(10); } // Loop indefinitely serving the config page
}

void setupWiFiSmart() {
  // Use the global prefs object for reading WiFi credentials
  if (!prefs.isKey("ssid")) { // Check if prefs was successfully begun before using isKey
     prefs.begin("assetmon", true); // Open read-only if not already begun
  }
  String ssid_from_prefs = prefs.getString("ssid", "");
  String pass_from_prefs = prefs.getString("pass", "");
  // prefs.end(); // Keep prefs open if it's global and used elsewhere, or manage its lifecycle carefully.
  // For this function, if it was opened here, it can be closed. If global, it depends.
  // Given your global `prefs`, it's likely intended to be open. Let's assume it's managed globally.

  if (ssid_from_prefs.length() == 0) {
    Serial.println("SSID not found in Preferences. Starting WiFi Configuration Portal.");
    startConfigPortal(); // This function will loop indefinitely until configured and rebooted
    return;
  }
  strncpy(wifi_ssid, ssid_from_prefs.c_str(), 32); wifi_ssid[32] = '\0';
  strncpy(wifi_pass, pass_from_prefs.c_str(), 64); wifi_pass[64] = '\0';

  WiFi.mode(WIFI_STA);
  WiFi.begin(wifi_ssid, wifi_pass);
  Serial.printf("Attempting to connect to WiFi SSID: %s", wifi_ssid);
  unsigned long connectStartTime = millis();
  while (WiFi.status() != WL_CONNECTED && (millis() - connectStartTime < 20000)) { // 20-second timeout
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("Successfully connected to WiFi!");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nFailed to connect to WiFi after 20 seconds. Starting WiFi Configuration Portal.");
    startConfigPortal(); // Fallback to AP mode for configuration
  }
}

// V21.ino (Continued - Chunk 4)

void loadConfig() {
  Preferences localPrefs; // Your existing code uses a local Preferences object here
  bool prefsOpenedForRead = localPrefs.begin("assetmon", true);

  if (!prefsOpenedForRead) {
    Serial.println("loadConfig: Failed to open preferences in read-only. Will use defaults and attempt save.");
    // Directly go to default setup if read fails.
    goto use_defaults_and_save;
  }

  if (localPrefs.isKey("cfg")) {
    size_t len = localPrefs.getBytes("cfg", &config, sizeof(config));
    if (len != sizeof(config)) {
      Serial.println("loadConfig: Config size mismatch. Using defaults and saving.");
      localPrefs.end(); // Close read-only before potentially opening for write in saveConfig
      goto use_defaults_and_save;
    }
    Serial.println("loadConfig: Configuration loaded from Preferences.");
    
    // Post-load checks and initializations for potentially new fields
    if (config.longStopThresholdSec == 0 && config.maxEvents !=0 ) { // Example of initializing a field if it's at a "new" default
        config.longStopThresholdSec = 5*60;
        Serial.println("loadConfig: Initialized longStopThresholdSec to default 5 minutes.");
    }
    // Check and initialize monitoringMode
    if (config.monitoringMode != MONITORING_MODE_PARALLEL && config.monitoringMode != MONITORING_MODE_SERIAL) {
        Serial.printf("loadConfig: monitoringMode invalid or uninitialized (value: %d), defaulting to Parallel.\n", config.monitoringMode);
        config.monitoringMode = MONITORING_MODE_PARALLEL;
        // We should save the config if we defaulted a value to ensure it's stored.
        // The original structure has saveConfig() called if 'cfg' key is missing.
        // If we modify 'config' here after loading, we should ensure it gets saved.
        // For simplicity, let's assume if we had to default monitoringMode, a subsequent save (e.g. from config page) will fix it.
        // Or, force a save:
        // localPrefs.end(); // Close read handle
        // saveConfig(); // This will open for write, save, and close.
        // localPrefs.begin("assetmon", true); // Reopen for read if needed, though not strictly necessary here.
    }

  } else {
    Serial.println("loadConfig: No 'cfg' key. Using defaults and saving.");
use_defaults_and_save:
    config.assetCount = 2; // Sensible default
    config.maxEvents = 1000; // Sensible default
    strcpy(config.assets[0].name, "Line 1"); config.assets[0].pin = 4; // Example
    strcpy(config.assets[1].name, "Line 2"); config.assets[1].pin = 12; // Example
    for (uint8_t i = config.assetCount; i < MAX_ASSETS; ++i) {
        strcpy(config.assets[i].name, ""); // Clear names for unused assets
        config.assets[i].pin = 0; // Use 0 or an invalid pin marker for unused assets
    }
    for (int i = 0; i < 5; ++i) {
      strncpy(config.downtimeReasons[i], DEFAULT_DOWNTIME_REASONS[i], sizeof(config.downtimeReasons[i]) - 1);
      config.downtimeReasons[i][sizeof(config.downtimeReasons[i]) - 1] = '\0';
    }
    config.tzOffset = 0; // Default to UTC
    config.longStopThresholdSec = 5*60; // Default 5 minutes
    config.monitoringMode = MONITORING_MODE_PARALLEL; // Default mode

    if (prefsOpenedForRead) localPrefs.end(); // Close read handle if it was open
    saveConfig(); // saveConfig handles its own begin/end
    // No need to reopen localPrefs here as loadConfig is done.
  }

  if (prefsOpenedForRead && localPrefs.freeEntries() > 0) { // Check if it was opened and can be ended.
    localPrefs.end();
  }
  Serial.printf("Monitoring Mode Loaded: %s\n", (config.monitoringMode == MONITORING_MODE_SERIAL) ? "Serial" : "Parallel");
}

void saveConfig() {
  Preferences localSavePrefs; // Your existing code uses a local Preferences object here

  if (!localSavePrefs.begin("assetmon", false)) { // false for read-write
    Serial.println("saveConfig: Failed to begin preferences for writing.");
    return;
  }

  if (localSavePrefs.putBytes("cfg", &config, sizeof(config)) == sizeof(config)) {
     Serial.println("saveConfig: Configuration saved successfully.");
  } else {
     Serial.println("saveConfig: Error writing configuration to preferences.");
  }
  localSavePrefs.end();
}

void setupTime() {
  // Apply TZ offset from loaded config
  // The format for setenv TZ can be complex for full DST rules.
  // Simple offset: "GMT+/-offset_hours" or "UTC+/-offset_hours"
  // config.tzOffset is in seconds. Convert to hours for standard TZ string.
  // Positive tzOffset means time is AHEAD of UTC (e.g., UTC+2). Standard TZ string is like "ETC/GMT-2".
  // Negative tzOffset means time is BEHIND UTC (e.g., UTC-5). Standard TZ string is like "ETC/GMT+5".
  // So, sign is inverted for the GMT string.
  
  char tzString[20];
  int tzOffsetHours = config.tzOffset / 3600;
  if (tzOffsetHours >= 0) {
    snprintf(tzString, sizeof(tzString), "Etc/GMT-%d", tzOffsetHours);
  } else {
    snprintf(tzString, sizeof(tzString), "Etc/GMT+%d", -tzOffsetHours);
  }
  // For DST, your original hardcoded "GMT0BST,M3.5.0/1,M10.5.0/2" is UK specific.
  // Using a simple offset might be more general if you don't need precise DST for all regions.
  // If you want to keep UK DST:
  // setenv("TZ", "GMT0BST,M3.5.0/1,M10.5.0/2", 1); // UK DST
  // If using tzOffset for a simple offset:
  setenv("TZ", tzString, 1);
  tzset();
  
  // Original NTP config
  configTime(0, 0, "pool.ntp.org", "time.nist.gov"); // Base UTC from NTP

  Serial.print("Waiting for NTP time sync...");
  time_t now_time = time(nullptr);
  int retry = 0;
  // Wait for time to be reasonable (e.g., after 2000, not close to epoch start 1970)
  while (now_time < 1609459200 && retry < 60) { // 1609459200 is Jan 1 2021
    delay(500);
    Serial.print(".");
    now_time = time(nullptr);
    retry++;
  }
  Serial.println(" done");

  if (now_time >= 1609459200) {
    struct tm timeinfo;
    getLocalTime(&timeinfo); // This will apply the TZ environment variable
    Serial.printf("NTP sync successful. Current local time: %s", asctime(&timeinfo));
  } else {
    Serial.println("NTP time sync failed or timed out. Using system boot time (if any). Dates/times may be incorrect.");
  }
}

// V21.ino (Continued - Chunk 5)

// --- New function to log system-wide events (for Serial mode) ---
void logSystemEvent(bool systemIsStarting, time_t now, const char* triggerAssetNameOrReason) {
  if (config.monitoringMode != MONITORING_MODE_SERIAL) return;

  struct tm* ti = localtime(&now);
  char datebuf[11], timebuf[9];
  strftime(datebuf, sizeof(datebuf), "%d/%m/%Y", ti);
  strftime(timebuf, sizeof(timebuf), "%H:%M:%S", ti);

  unsigned long currentTotalRun = g_systemTotalRunningTimeSecs;
  unsigned long currentTotalStop = g_systemTotalStoppedTimeSecs;
  // Note: Durations *leading up to this event* were added in loop().
  // For display at the moment of the event, these are the correct totals *before* this event's impact on future accumulation.

  float sysAvail = (currentTotalRun + currentTotalStop) > 0
                   ? (100.0f * currentTotalRun / (currentTotalRun + currentTotalStop))
                   : (systemIsStarting ? 100.0f : 0.0f);
  float sysRTM_minutes = (float)currentTotalRun / 60.0f;
  float sysSTM_minutes = (float)currentTotalStop / 60.0f;

  float sysMTBF_minutes = (g_systemStopCount > 0)
                          ? ((float)currentTotalRun / g_systemStopCount / 60.0f)
                          : (currentTotalRun > 0 ? sysRTM_minutes : 0.0f);
  float sysMTTR_minutes = (g_systemStopCount > 0)
                          ? ((float)currentTotalStop / g_systemStopCount / 60.0f)
                          : 0.0f;

  String eventName = systemIsStarting ? "SYS_START" : "SYS_STOP";
  String assetColumnValue = "SYSTEM"; // Default for SYS_START
  String noteForLog = "";

  if (!systemIsStarting) { // For SYS_STOP
    assetColumnValue = (triggerAssetNameOrReason && strlen(triggerAssetNameOrReason) > 0) ? triggerAssetNameOrReason : "SYSTEM_WIDE";
    noteForLog = "System Stop Triggered";
    if (triggerAssetNameOrReason && strlen(triggerAssetNameOrReason) > 0 && strcmp(triggerAssetNameOrReason, "SYSTEM_WIDE") != 0 && strcmp(triggerAssetNameOrReason, "SYSTEM") != 0) {
        noteForLog = String("Trigger: ") + triggerAssetNameOrReason;
    }
  } else { // For SYS_START
    noteForLog = (triggerAssetNameOrReason && strlen(triggerAssetNameOrReason) > 0) ? triggerAssetNameOrReason : "System Recovered";
  }

  File f = SPIFFS.open(LOG_FILENAME, FILE_APPEND);
  if (!f) {
    Serial.println("logSystemEvent: Failed to open log file!");
    return;
  }
  f.printf("%s,%s,%s,%s,%d,%.2f,%.2f,%.2f,%.2f,%.2f,%u,,, %s\n",
           datebuf, timebuf,
           assetColumnValue.c_str(),
           eventName.c_str(),
           systemIsStarting ? 1 : 0,
           sysAvail, sysRTM_minutes, sysSTM_minutes, sysMTBF_minutes, sysMTTR_minutes,
           g_systemStopCount,
           noteForLog.c_str());
  f.close();

  Serial.printf("SYSTEM Event: %s. AssetCol: %s. Note: %s. SysAvail:%.2f, SysStops:%u\n",
                eventName.c_str(), assetColumnValue.c_str(), noteForLog.c_str(), sysAvail, g_systemStopCount);
}


void setup() {
  Serial.begin(115200);
  Serial.println("\n--- Device Starting (V21 Patched) ---");

  if (!SPIFFS.begin(true)) { Serial.println("SPIFFS.begin() failed! Halting."); return; }
  Serial.println("SPIFFS initialized.");

  // Initialize global prefs object for WiFi (and potentially other uses if refactored)
  if (!prefs.begin("assetmon", false)) { // Open read-write for initial setup if needed
      Serial.println("Global prefs.begin() failed during setup! WiFi saving might fail.");
  } else {
      Serial.println("Global Preferences initialized.");
  }
  // Note: loadConfig and saveConfig in your version use their own local Preferences instances.

  loadConfig(); // Loads 'config' struct, including monitoringMode
  Serial.println("Configuration loaded/initialized.");

  setupWiFiSmart(); // Uses global 'prefs' for SSID/Pass
  setupTime();      // Uses 'config.tzOffset'
  Serial.println("WiFi and Time setup complete.");

  Serial.printf("Initializing %u assets...\n", config.assetCount);
  time_t initialTime = time(nullptr);
  for (uint8_t i = 0; i < config.assetCount; ++i) {
    if (i < MAX_ASSETS) {
      if (config.assets[i].pin > 0 && config.assets[i].pin < 40) { // Basic GPIO validity for common ESP32 pins
          pinMode(config.assets[i].pin, INPUT_PULLUP);
          assetStates[i].lastState = digitalRead(config.assets[i].pin);
      } else {
          Serial.printf("Warning: Asset %s (idx %u) has invalid pin %u. Defaulting to STOPPED state and marking pin unusable.\n", config.assets[i].name, i, config.assets[i].pin);
          assetStates[i].lastState = true; // Default to stopped
          // config.assets[i].pin = 255; // Mark as unusable if needed, though loop logic should also check
      }
      assetStates[i].lastChangeTime = initialTime;
      assetStates[i].sessionStart = initialTime;
      assetStates[i].runningTime = 0; assetStates[i].stoppedTime = 0;
      assetStates[i].runCount = 0; assetStates[i].stopCount = 0;
      assetStates[i].lastEventTime = initialTime;
      assetStates[i].lastRunDuration = 0; assetStates[i].lastStopDuration = 0;
      Serial.printf("Asset %u ('%s', pin %u) init. Pin State: %s (Input means: %s)\n",
                    i, config.assets[i].name, config.assets[i].pin,
                    assetStates[i].lastState ? "HIGH" : "LOW",
                    assetStates[i].lastState ? "STOPPED" : "RUNNING");
    }
  }

  // --- Initialize System State for Serial Mode ---
  if (config.monitoringMode == MONITORING_MODE_SERIAL) {
    g_systemLastStateChangeTime = initialTime;
    bool anyAssetInitiallyStopped = false;
    g_serialSystemTriggerAssetName[0] = '\0';

    for (uint8_t i = 0; i < config.assetCount; ++i) {
      if (i < MAX_ASSETS) {
        bool assetEffectivelyStopped = assetStates[i].lastState;
        // Also consider an asset with an invalid/unconfigured pin as stopped for system evaluation
        if (config.assets[i].pin == 0 || config.assets[i].pin >= 40) { // Assuming pins >= 40 are invalid
             assetEffectivelyStopped = true;
        }
        if (assetEffectivelyStopped) {
            anyAssetInitiallyStopped = true;
            if (g_serialSystemTriggerAssetName[0] == '\0') {
                strncpy(g_serialSystemTriggerAssetName, config.assets[i].name, 31);
                g_serialSystemTriggerAssetName[31] = '\0';
            }
        }
      }
    }
    g_isSystemSerialDown = anyAssetInitiallyStopped;
    g_systemStateInitialized = true;
    Serial.printf("Serial Mode: Initial system state set. System Down: %s. Trigger: '%s'\n",
                  g_isSystemSerialDown ? "Yes" : "No",
                  g_isSystemSerialDown ? g_serialSystemTriggerAssetName : "N/A");
    
    // Log the initial system state determined at boot
    if (g_isSystemSerialDown) {
        logSystemEvent(false, initialTime, g_serialSystemTriggerAssetName);
    } else {
        logSystemEvent(true, initialTime, "System Initialized - All Assets Up");
    }
  }
  // --- End System State Initialization ---

  server.on("/", HTTP_GET, []() { server.send(200, "text/html", htmlDashboard()); });
  server.on("/dashboard", HTTP_GET, []() { server.send(200, "text/html", htmlDashboard()); });
  server.on("/config", HTTP_GET, []() { server.send(200, "text/html", htmlConfig()); });
  server.on("/events", HTTP_GET, sendHtmlEventsPage);
  server.on("/asset", HTTP_GET, []() {
    if (server.hasArg("idx")) {
      uint8_t idx = server.arg("idx").toInt();
      if (idx < config.assetCount && idx < MAX_ASSETS) { server.send(200, "text/html", htmlAssetDetail(idx)); return; }
    }
    server.send(404, "text/plain", "Asset not found");
  });

  server.on("/analytics", HTTP_GET, []() { server.send(200, "text/html", htmlAnalytics()); });
  server.on("/analytics-compare", HTTP_GET, []() { server.send(200, "text/html", htmlAnalyticsCompare()); });
  server.on("/reconfigure_wifi", HTTP_POST, handleWiFiReconfigurePost);
  server.on("/save_config", HTTP_POST, handleConfigPost); // Changed from /config_save
  server.on("/clear_log", HTTP_POST, handleClearLog);    // Changed from /clearlog (GET)
  server.on("/export_log", HTTP_GET, handleExportLog);  // Was /exportlog
  server.on("/api/summary", HTTP_GET, handleApiSummary);
  server.on("/api/events", HTTP_GET, handleApiEvents);
  server.on("/api/config", HTTP_GET, handleApiConfig);
  server.on("/api/note", HTTP_POST, handleApiNote); // Was /api/note_update
  server.onNotFound(handleNotFound);

  server.begin();
  Serial.println("Web server started. Device is ready.");
}

// V21.ino (Continued - Chunk 6)

void loop() {
  server.handleClient();
  time_t now = time(nullptr);

  // --- I. Individual Asset State Monitoring & Event Logging ---
  for (uint8_t i = 0; i < config.assetCount; ++i) {
    if (i >= MAX_ASSETS) continue;

    // Determine current pin state, defaulting to STOPPED if pin is invalid
    bool current_pin_state = true; // Assume stopped
    if (config.assets[i].pin > 0 && config.assets[i].pin < 40) { // Valid pin range
        current_pin_state = digitalRead(config.assets[i].pin); // true if HIGH (STOPPED)
    } else {
        // For assets with invalid pins, their lastState should remain true (STOPPED)
        // and they shouldn't trigger a state change log event unless their configured pin changes.
        // We ensure assetStates[i].lastState reflects this expectation.
        if (assetStates[i].lastState == false) { // If it was somehow marked running with an invalid pin
             assetStates[i].lastState = true;    // Correct it to stopped
             assetStates[i].lastChangeTime = now; // And mark the change time
        }
        // Skip further processing for this asset in parallel mode if pin is invalid
        if (config.monitoringMode == MONITORING_MODE_PARALLEL) continue; 
        // In serial mode, an invalid pin means this asset is considered "stopped" for system evaluation
    }
    
    if (current_pin_state != assetStates[i].lastState) {
      unsigned long elapsed = now - assetStates[i].lastChangeTime;
      unsigned long runDuration = 0;
      unsigned long stopDuration = 0;
      char eventNoteBuffer[128] = ""; // For "Consequence Stop"

      if (current_pin_state == true) { // Machine just STOPPED (was running)
        assetStates[i].runningTime += elapsed;
        assetStates[i].stopCount++;
        runDuration = elapsed;
        assetStates[i].lastRunDuration = runDuration;
        assetStates[i].lastStopDuration = 0;

        if (config.monitoringMode == MONITORING_MODE_SERIAL && g_isSystemSerialDown &&
            strlen(g_serialSystemTriggerAssetName) > 0 &&
            strcmp(config.assets[i].name, g_serialSystemTriggerAssetName) != 0) {
          snprintf(eventNoteBuffer, sizeof(eventNoteBuffer), "Consequence Stop (System: %s)", g_serialSystemTriggerAssetName);
        }
        logEvent(i, false, now, eventNoteBuffer[0] ? eventNoteBuffer : nullptr, runDuration, 0);
      
      } else { // Machine just STARTED (was stopped)
        assetStates[i].stoppedTime += elapsed;
        assetStates[i].runCount++;
        stopDuration = elapsed;
        assetStates[i].lastStopDuration = stopDuration;
        assetStates[i].lastRunDuration = 0;
        logEvent(i, true, now, nullptr, 0, stopDuration);
      }
      assetStates[i].lastState = current_pin_state;
      assetStates[i].lastChangeTime = now;
    }
  } // End of individual asset loop

  // --- II. System State Logic (Serial Mode Only) ---
  if (config.monitoringMode == MONITORING_MODE_SERIAL) {
    if (!g_systemStateInitialized) { // Should have been initialized in setup
        g_systemLastStateChangeTime = now;
        bool anyAssetInitiallyStoppedLoop = false;
        g_serialSystemTriggerAssetName[0] = '\0';
        for (uint8_t k = 0; k < config.assetCount; ++k) {
            if (k < MAX_ASSETS) {
                bool assetEffectivelyStoppedLoop = assetStates[k].lastState;
                 if (config.assets[k].pin == 0 || config.assets[k].pin >= 40) {
                    assetEffectivelyStoppedLoop = true;
                 }
                if (assetEffectivelyStoppedLoop) {
                    anyAssetInitiallyStoppedLoop = true;
                    if (g_serialSystemTriggerAssetName[0] == '\0') {
                        strncpy(g_serialSystemTriggerAssetName, config.assets[k].name, 31);
                        g_serialSystemTriggerAssetName[31] = '\0';
                    }
                }
            }
        }
        g_isSystemSerialDown = anyAssetInitiallyStoppedLoop;
        g_systemStateInitialized = true;
        Serial.println("Serial Mode: System state re-initialized in loop (fallback).");
        logSystemEvent(!g_isSystemSerialDown, now, g_isSystemSerialDown ? g_serialSystemTriggerAssetName : "System Initialized - All Up (Loop)");
    }

    bool isAnyAssetCurrentlyStopped = false;
    char currentCycleTriggerAssetName[32] = ""; 
    currentCycleTriggerAssetName[0] = '\0';

    for (uint8_t j = 0; j < config.assetCount; ++j) {
      if (j < MAX_ASSETS) {
        bool assetEffectivelyStopped = assetStates[j].lastState;
        // An asset with an invalid/unconfigured pin is considered "stopped" for system evaluation
        if (config.assets[j].pin == 0 || config.assets[j].pin >= 40) { // Assuming pins >= 40 are invalid
             assetEffectivelyStopped = true;
        }

        if (assetEffectivelyStopped) {
          isAnyAssetCurrentlyStopped = true;
          if (currentCycleTriggerAssetName[0] == '\0') { // Capture the first stopped asset
            strncpy(currentCycleTriggerAssetName, config.assets[j].name, 31);
            currentCycleTriggerAssetName[31] = '\0';
          }
        }
      }
    }

    // Handle System Transition to DOWN
    if (isAnyAssetCurrentlyStopped && !g_isSystemSerialDown) {
      unsigned long systemUpDuration = now - g_systemLastStateChangeTime;
      g_systemTotalRunningTimeSecs += systemUpDuration;
      g_isSystemSerialDown = true;
      g_systemLastStateChangeTime = now;
      g_systemStopCount++;
      strncpy(g_serialSystemTriggerAssetName, currentCycleTriggerAssetName, 31); // currentCycleTriggerAssetName should be set if isAnyAssetCurrentlyStopped is true
      g_serialSystemTriggerAssetName[31] = '\0';
      if (strlen(g_serialSystemTriggerAssetName) == 0 && isAnyAssetCurrentlyStopped) strcpy(g_serialSystemTriggerAssetName, "Unknown"); // Fallback
      logSystemEvent(false, now, g_serialSystemTriggerAssetName);
      Serial.printf("Serial Mode: System -> DOWN. Trigger: %s. Up Duration: %lu s\n", g_serialSystemTriggerAssetName, systemUpDuration);
    }
    // Handle System Transition to UP
    else if (!isAnyAssetCurrentlyStopped && g_isSystemSerialDown) {
      unsigned long systemDownDuration = now - g_systemLastStateChangeTime;
      g_systemTotalStoppedTimeSecs += systemDownDuration;
      g_isSystemSerialDown = false;
      g_systemLastStateChangeTime = now;
      g_serialSystemTriggerAssetName[0] = '\0';
      logSystemEvent(true, now, "All Assets Recovered");
      Serial.printf("Serial Mode: System -> UP. Down Duration: %lu s\n", systemDownDuration);
    }
  }
  delay(200); // Main loop delay
}

// V21.ino (Continued - Chunk 7: Logging and Utility Functions - Minor adjustments if needed)

// logEvent: Accepts customNote for "Consequence Stop"
void logEvent(uint8_t assetIdx, bool machineIsRunning, time_t now, const char* customNote, unsigned long runDuration, unsigned long stopDuration) {
  if (assetIdx >= MAX_ASSETS) return;

  AssetState& as = assetStates[assetIdx];
  // Cumulative stats are updated *before* this event for calculation of metrics *at the time of this event*
  unsigned long cumulative_runningTime = as.runningTime;
  unsigned long cumulative_stoppedTime = as.stoppedTime;

  // If this event is a STOP, the runDuration that just ENDED is added to cumulative_runningTime for MTBF calc
  // If this event is a START, the stopDuration that just ENDED is added to cumulative_stoppedTime for MTTR calc
  // The assetStates[i].runningTime/stoppedTime in loop() are updated *before* calling logEvent.

  float avail = (cumulative_runningTime + cumulative_stoppedTime) > 0
                ? (100.0 * cumulative_runningTime / (cumulative_runningTime + cumulative_stoppedTime))
                : (machineIsRunning ? 100.0 : 0.0);

  float total_runtime_min = cumulative_runningTime / 60.0;
  float total_downtime_min = cumulative_stoppedTime / 60.0;

  // as.stopCount is the count of *completed* stop cycles.
  // If this is a STOP event, stopCount has just been incremented in loop()
  // If this is a START event, stopCount reflects stops before this run.
  uint32_t stops_for_mtbf_calc = machineIsRunning ? as.stopCount : as.stopCount; // if running, use current stopCount for MTBF of runs ending in those stops
                                                                                   // if stopping, stopCount was just incremented, use that.
  uint32_t stops_for_mttr_calc = as.stopCount; // MTTR is based on completed stop cycles.

  float mtbf_val = (stops_for_mtbf_calc > 0) ? (float)cumulative_runningTime / stops_for_mtbf_calc / 60.0 : total_runtime_min;
  float mttr_val = (stops_for_mttr_calc > 0) ? (float)cumulative_stoppedTime / stops_for_mttr_calc / 60.0 : 0;

  struct tm * ti = localtime(&now);
  char datebuf[11], timebuf[9];
  strftime(datebuf, sizeof(datebuf), "%d/%m/%Y", ti);
  strftime(timebuf, sizeof(timebuf), "%H:%M:%S", ti);

  File f = SPIFFS.open(LOG_FILENAME, FILE_APPEND);
  if (!f) { Serial.println("Failed to open log file for writing!"); return; }
  f.printf("%s,%s,%s,%s,%d,%.2f,%.2f,%.2f,%.2f,%.2f,%u,%s,%s,%s\n",
    datebuf, timebuf, config.assets[assetIdx].name,
    machineIsRunning ? "START" : "STOP",
    machineIsRunning ? 1 : 0,
    avail, total_runtime_min, total_downtime_min, mtbf_val, mttr_val,
    as.stopCount, // Log the current stop count of the asset
    (runDuration > 0 ? formatMMSS(runDuration).c_str() : ""),
    (stopDuration > 0 ? formatMMSS(stopDuration).c_str() : ""),
    customNote ? customNote : "" // Use customNote if provided
  );
  f.close();
  as.lastEventTime = now;
  Serial.printf("Event logged for %s: %s. Note: '%s'. RunD: %s, StopD: %s. Stops: %u\n",
    config.assets[assetIdx].name, machineIsRunning ? "START" : "STOP",
    customNote ? customNote : "",
    formatMMSS(runDuration).c_str(), formatMMSS(stopDuration).c_str(), as.stopCount
  );
}

String formatMMSS(unsigned long seconds) {
  if (seconds == 0) return ""; // Return empty for 0, or "00:00" if you prefer
  unsigned int min_val = seconds / 60;
  unsigned int sec_val = seconds % 60;
  char buf[8]; // "MM:SS" + null
  sprintf(buf, "%02u:%02u", min_val, sec_val);
  return String(buf);
}

// eventToCSV, urlEncode, urlDecode - no changes from your V21
String eventToCSV(const Event& e) {
  struct tm * ti = localtime(&e.timestamp);
  char datebuf[16], timebuf[16];
  strftime(datebuf, sizeof(datebuf), "%d/%m/%Y", ti);
  strftime(timebuf, sizeof(timebuf), "%H:%M:%S", ti);

  String csv = String(datebuf) + "," + String(timebuf) + "," +
               String(e.assetName) + "," + String(e.eventType) + "," +
               String(e.state) + "," + String(e.availability, 2) + "," +
               String(e.runtime, 2) + "," + String(e.downtime, 2) + "," +
               String(e.mtbf, 2) + "," + String(e.mttr, 2) + "," +
               String(e.stops) + "," +
               String(e.runDuration) + "," + String(e.stopDuration) + "," +
               String(e.note);
  return csv;
}

String urlEncode(const String& str) {
  String encodedString = ""; char c; char code0; char code1;
  for (unsigned int i = 0; i < str.length(); i++) {
    c = str.charAt(i);
    if (c == ' ') encodedString += '+';
    else if (isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~') encodedString += c;
    else {
      code1 = (c & 0xf) + '0'; if ((c & 0xf) > 9) code1 = (c & 0xf) - 10 + 'A';
      c = (c >> 4) & 0xf; code0 = c + '0'; if (c > 9) code0 = c - 10 + 'A';
      encodedString += '%'; encodedString += code0; encodedString += code1;
    }
  }
  return encodedString;
}
String urlDecode(const String& str) {
  String decoded = ""; char temp[] = "0x00"; unsigned int len = str.length(); unsigned int i = 0;
  while (i < len) {
    char c = str.charAt(i);
    if (c == '%') {
      if (i+2 < len) { temp[2] = str.charAt(i+1); temp[3] = str.charAt(i+2); decoded += char(strtol(temp, NULL, 16)); i += 3; }
      else { i++; } // Incomplete escape, skip
    } else if (c == '+') { decoded += ' '; i++; }
    else { decoded += c; i++; }
  }
  return decoded;
}

// V21.ino (Continued - Chunk 8: HTML Functions)

String htmlDashboard() {
  String html = "<!DOCTYPE html><html lang='en'><head><title>Dashboard</title>";
  html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<link href='https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap' rel='stylesheet'>";
  html += "<script src='https://cdn.jsdelivr.net/npm/chart.js'></script>";
  html += "<style>";
  html += "body{font-family:Roboto,Arial,sans-serif;background:#f3f7fa;margin:0;padding:0;}";
  html += "header{background:#1976d2;color:#fff;padding:1.3rem 0 1.3rem 2rem;text-align:left;font-size:2em;font-weight:700;box-shadow:0 2px 10px #0001;}";
  html += ".nav{display:flex;justify-content:center;align-items:center;gap:1rem;margin:1.5rem 0 1rem 0;flex-wrap:wrap;}";
  html += ".nav .nav-btn{background:#fff;color:#1976d2;border:none;border-radius:8px;padding:0.7em 1.3em;font-size:1.13em;font-weight:700;box-shadow:0 2px 12px #1976d222;cursor:pointer;transition:.2s;text-decoration:none;}"; // Added text-decoration
  html += ".nav .nav-btn:hover{background:#e3f0fc;}";
  html += ".main{max-width:1200px;margin:1rem auto;padding:1rem;}";
  html += ".card{background:#fff;border-radius:10px;box-shadow:0 2px 16px #0002;margin-bottom:1.3rem;padding:1.3rem;}";
  html += "#chart-container{width:100%;overflow-x:auto;}";
  html += ".statrow{display:flex;gap:1.5em;flex-wrap:wrap;justify-content:center;margin:2em 0 2em 0;}";
  html += ".stat{flex:1 1 220px;border-radius:10px;padding:1.2em;text-align:left;font-size:1.1em;margin:0.4em 0;box-shadow:0 2px 8px #0001;font-weight:500;background:#f5f7fa;border:2px solid #e0e0e0;min-width:200px;}"; // Added min-width
  html += ".stat.stopped{background:#ffeaea;border-color:#f44336;}";
  html += ".stat.running{background:#e6fbe7;border-color:#54c27c;}";
  html += "table{width:100%;border-collapse:collapse;font-size:1em;margin-top:2em;}";
  html += "th,td{padding:0.7em 0.5em;text-align:left;border-bottom:1px solid #eee;}";
  html += "th{background:#2196f3;color:#fff;}";
  html += "tr{background:#fcfcfd;} tr:nth-child(even){background:#f3f7fa;}";
  html += "td:last-child .nav-btn{margin:0;}";
  html += "@media (max-width:900px){.main{padding:0.5em;}.statrow{gap:0.5em;}.stat{min-width:150px;max-width:100%;font-size:1em;padding:0.6em;}}";
  html += "@media (max-width:700px){header{font-size:1.3em;padding:1em 0 1em 1em;}.nav{flex-direction:column;align-items:center;margin:1em 0 1em 0;gap:0.4em;}.card{padding:0.7em;}.statrow{gap:0.4em;margin:1em 0;}}";
  html += "</style>";
  html += "</head><body>";
  html += "<header>Dashboard</header>";
  html += "<nav class='nav'>";
  html += "<form action='/events' style='margin:0;'><button type='submit' class='nav-btn'>Event Log</button></form>";
  html += "<form action='/config' style='margin:0;'><button type='submit' class='nav-btn'>Setup</button></form>";
  html += "<a href='/analytics-compare' class='nav-btn'>Compare Assets</a>"; // This was a link
  html += "<form action='/export_log' style='margin:0;'><button type='submit' class='nav-btn'>Export CSV</button></form>";
  html += "</nav>";
  html += "<div class='main'>";
  html += "<div id='systemWideStatus'></div>"; // <<< Placeholder for System Status Card
  html += "<div class='card'>";
  html += "<div id='chart-container'><canvas id='barChart' height='200'></canvas></div>";
  html += "<div class='statrow' id='statrow'></div>";
  html += "<div style='overflow-x:auto;'><table id='summaryTable'><thead><tr>";
  html += "<th>Name</th><th>State</th><th>Avail (%)</th><th>Runtime</th><th>Downtime</th><th>MTBF</th><th>MTTR</th><th>Stops</th><th>Actions</th></tr></thead><tbody></tbody></table>";
  html += "</div></div></div>";
  html += "<script>";
  html += R"rawliteral(
function formatHHMMSS(valInMinutes) { // Expects minutes
  if (isNaN(valInMinutes) || valInMinutes < 0.01) return "00:00:00";
  let totalSeconds = Math.round(valInMinutes * 60);
  let h = Math.floor(totalSeconds / 3600);
  let m = Math.floor((totalSeconds % 3600) / 60); // Corrected modulo for minutes
  let s = totalSeconds % 60;
  return (h < 10 ? "0" : "") + h + ":" + (m < 10 ? "0" : "") + m + ":" + (s < 10 ? "0" : "") + s;
}
let chartObj=null; // Your existing chart object
function updateDashboard() {
  fetch('/api/summary').then(r=>r.json()).then(data=>{
    // --- System Status Card ---
    const systemStatusContainer = document.getElementById('systemWideStatus');
    let systemCardHtml = "";
    if (data.monitoringMode === 1 && data.systemStats) { // MONITORING_MODE_SERIAL is 1
        let systemStateClass = data.systemStats.isDown ? "stopped" : "running";
        let systemStatusText = data.systemStats.isDown ? "DOWN" : "UP";
        systemCardHtml = `
            <div class='card system-status-card ${systemStateClass}' style='border: 3px solid ${data.systemStats.isDown ? "#f44336" : "#54c27c"}; margin-bottom:1.5em; background-color: ${data.systemStats.isDown ? "#ffebee" : "#e8f5e9"};'>
                <h2 style='text-align:center; color: ${data.systemStats.isDown ? "#d32f2f" : "#388e3c"}; margin-top:0.5em; margin-bottom:0.8em;'>Overall System: ${systemStatusText}</h2>
        `;
        if (data.systemStats.isDown && data.systemStats.triggerAsset && data.systemStats.triggerAsset.length > 0) {
            systemCardHtml += `<p style='text-align:center; font-weight:bold; font-size:1.1em; margin-bottom:1em;'>Triggered by: ${data.systemStats.triggerAsset}</p>`;
        }
        systemCardHtml += `
                <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:0.8em;">
                  <p style="margin:0.3em 0;"><strong>Availability:</strong> ${data.systemStats.availability.toFixed(2)}%</p>
                  <p style="margin:0.3em 0;"><strong>Total Running:</strong> ${formatHHMMSS(data.systemStats.totalRunningTimeSecs / 60.0)}</p>
                  <p style="margin:0.3em 0;"><strong>Total Stopped:</strong> ${formatHHMMSS(data.systemStats.totalStoppedTimeSecs / 60.0)}</p>
                  <p style="margin:0.3em 0;"><strong>System Stops:</strong> ${data.systemStats.stopCount}</p>
                  <p style="margin:0.3em 0;"><strong>System MTBF:</strong> ${formatHHMMSS(data.systemStats.mtbf_min)}</p>
                  <p style="margin:0.3em 0;"><strong>System MTTR:</strong> ${formatHHMMSS(data.systemStats.mttr_min)}</p>
                </div>
            </div>
        `;
    }
    if (systemStatusContainer) {
        systemStatusContainer.innerHTML = systemCardHtml;
    }
    // --- End System Status Card ---

    let tbody = document.querySelector('#summaryTable tbody');
    if (!tbody) return;
    let assets = data.assets;
    let rows = tbody.rows;
    let statrow = document.getElementById('statrow');
    if(statrow) statrow.innerHTML = '';

    let n = assets.length;
    for(let i=0;i<n;++i){
      let asset = assets[i];
      let stateClass = asset.state==1 ? "running" : "stopped";
      let row = rows[i];
      if (!row) {
        row = tbody.insertRow();
        for (let j=0;j<9;++j) row.insertCell();
      }
      let assetNameEncoded = encodeURIComponent(asset.name);
      let v0 = asset.name,
          v1 = `<span style="color:${asset.state==1?'#256029':'#b71c1c'};font-weight:bold">${asset.state==1?'RUNNING':'STOPPED'}</span>`,
          v2 = asset.availability.toFixed(2),
          v3 = formatHHMMSS(asset.total_runtime), // these keys are from your API
          v4 = formatHHMMSS(asset.total_downtime),
          v5 = formatHHMMSS(asset.mtbf),
          v6 = formatHHMMSS(asset.mttr),
          v7 = asset.stop_count,
          // MODIFIED v8: Only the Analytics button form remains
          v8 = `<form action='/analytics' method='GET' style='display:inline; margin:0;'><input type='hidden' name='asset' value="${assetNameEncoded}"><button type='submit' class='nav-btn'>Analytics</button></form>`;
      let vals = [v0,v1,v2,v3,v4,v5,v6,v7,v8];
      for(let j=0;j<9;++j) row.cells[j].innerHTML = vals[j];

      if(statrow) {
        let statHtml = `<div class='stat ${stateClass}'><b>${asset.name}</b><br>Avail: ${asset.availability.toFixed(1)}%<br>Run: ${formatHHMMSS(asset.total_runtime)}<br>Stops: ${asset.stop_count}</div>`;
        statrow.innerHTML += statHtml;
      }
    }
    while (rows.length > n) tbody.deleteRow(rows.length-1);

    let availData=[], names=[], runtimeData=[], downtimeData=[];
    for (let asset of assets) {
      availData.push(asset.availability);
      runtimeData.push(asset.total_runtime); // API key
      downtimeData.push(asset.total_downtime); // API key
      names.push(asset.name);
    }
    let ctxEl = document.getElementById('barChart');
    if (!ctxEl) return;
    let ctx = ctxEl.getContext('2d');

    if (!window.chartObj) {
      window.chartObj = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: names,
          datasets: [
            { label: 'Availability (%)', data: availData, backgroundColor: '#42a5f5', yAxisID: 'y' },
            { label: 'Runtime (min)', data: runtimeData, backgroundColor: '#66bb6a', yAxisID: 'y1' },
            { label: 'Downtime (min)', data: downtimeData, backgroundColor: '#ef5350', yAxisID: 'y1' }
          ]
        },
        options: {
          responsive:true, maintainAspectRatio:false,
          scales: {
            y: { beginAtZero:true, max:100, title:{display:true,text:'Availability (%)'} },
            y1: { beginAtZero:true, position: 'right', grid: { drawOnChartArea: false }, title: { display:true, text:'Runtime/Downtime (min)' }}
          }
        }
      });
    } else {
      window.chartObj.data.labels = names;
      window.chartObj.data.datasets[0].data = availData;
      window.chartObj.data.datasets[1].data = runtimeData;
      window.chartObj.data.datasets[2].data = downtimeData;
      window.chartObj.update();
    }
  }).catch(e => console.error("Dashboard update error:", e));
}
if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', updateDashboard); }
else { updateDashboard(); }
setInterval(updateDashboard, 5000);
)rawliteral";
  html += "</script></body></html>";
  return html;
}


String htmlAnalytics() {
  String assetName = server.hasArg("asset") ? urlDecode(server.arg("asset")) : "";
  String html = "<!DOCTYPE html><html lang='en'><head><title>Analytics: ";
  html += assetName + "</title>";
  html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<link href='https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap' rel='stylesheet'>";
  html += "<script src='https://cdn.jsdelivr.net/npm/chart.js'></script>";
  html += "<style>body{font-family:Roboto,sans-serif;background:#f3f7fa;margin:0;}th,td{text-align:left;}header{background:#1976d2;color:#fff;padding:1.3rem 0;text-align:center;box-shadow:0 2px 10px #0001;font-size:2em;}.nav{display:flex;justify-content:center;gap:1rem;margin:1rem 0;flex-wrap:wrap;}.nav button, .nav a{background:#fff;color:#1976d2;border:none;border-radius:6px;padding:0.7em 1.1em;font-size:1.1em;font-weight:700;box-shadow:0 2px 8px #0001;cursor:pointer;text-decoration:none;display:inline-block;}.nav button:hover, .nav a:hover{background:#e3f0fc;}.nav .analytics-btn{background:#fff;color:#ffa726;border:1.5px solid #ff9800;}.nav .analytics-btn:hover{background:#fff3e0;}.main{max-width:1100px;margin:1rem auto;padding:1rem;}.metrics{display:flex;gap:2em;flex-wrap:wrap;margin-bottom:1.2em;}.metric{background:#f8fafb;border-radius:7px;padding:0.9em 1.5em;font-size:1.2em;margin:0.3em 0;box-shadow:0 2px 8px #0001;font-weight:500;}.controls{display:flex;gap:1em;align-items:center;margin-bottom:1.5em;flex-wrap:wrap;}.controls label{font-weight:500;}.controls input[type='datetime-local']{padding:0.3em;font-size:1em;}.controls .toggle{margin-left:0.5em;}.controls .export-btn{margin-left:0.5em;padding:0.4em 1em;background:#1976d2;color:#fff;border:none;border-radius:4px;cursor:pointer;}.controls .export-btn:hover{background:#135da0;}.chartcard{background:#fff;border-radius:10px;box-shadow:0 2px 10px #0001;margin:1.5em 0;padding:1em;}.tablecard{overflow-x:auto;}@media(max-width:700px){header{font-size:1.3em;}.metrics{gap:1em;flex-direction:column;}.main{padding:0.6em;}.chartcard{padding:0.7em;}}</style>";
  html += "</head><body>";
  html += "<header>Analytics: <span id='assetNameInHeader'>" + assetName + "</span></header>";
  html += "<nav class='nav'>";
  html += "<a href='/'>Dashboard</a>";
  html += "<a href='/events'>Event Log</a>";
  html += "<a href='/analytics-compare' class='analytics-btn'>Compare Assets</a>";
  html += "</nav>";
  html += "<div class='main'>";
  html += "<div class='metrics' id='kpiMetrics'></div>";
  html += "<div style='margin-bottom:0.5em; color:#888; font-size:1em;'>(Durations in <b>h:mm:ss</b> or <b>mm:ss</b>)</div>";
  html += "<div class='controls'>";
  html += "<label>From: <input type='datetime-local' id='fromTime'></label>";
  html += "<label>To: <input type='datetime-local' id='toTime'></label>";
  html += "<label class='toggle'><input type='checkbox' id='showStart' checked> Show START</label>";
  html += "<label class='toggle'><input type='checkbox' id='showStop' checked> Show STOP</label>";
  html += "<label class='toggle'><input type='checkbox' id='showMTBF'> Show MTBF</label>";
  html += "<label class='toggle'><input type='checkbox' id='showMTTR'> Show MTTR</label>";
  html += "<button class='export-btn' id='exportPng'>Export PNG</button>";
  html += "</div>";
  html += "<div class='chartcard'><canvas id='eventChart' style='width:100%;max-width:1050px;height:340px;'></canvas></div>";
  html += "<div class='tablecard'>";
  html += "<h3>Recent Events</h3><table style='width:100%;'><thead><tr>"
          "<th>Date</th><th>Time</th><th>Asset</th><th>Event</th><th>Avail(%)</th><th>Runtime</th><th>Downtime</th><th>MTBF</th><th>MTTR</th><th>Stops</th><th>Run Duration</th><th>Stop Duration</th><th>Note</th></tr></thead>"
          "<tbody id='recentEvents'></tbody></table></div>";
  html += "<script>\n";
  html += "console.log('Analytics script started (v14 - Enhanced MTBF/MTTR tooltips).');\n";
  html += "\n";
  html += "// --- Utility Functions ---\n";
  html += "function normalizeAssetName(name) {\n";
  html += "    return (name || '').toLowerCase().replace(/\\s+/g, '');\n";
  html += "}\n";
  html += "function floatMinToMMSS(val) { \n";
  html += "  if (typeof val === \"string\") val = parseFloat(val);\n";
  html += "  if (isNaN(val) || val < 0) {\n";
  html += "      let totalSeconds = 0; \n";
  html += "      let m = Math.floor(totalSeconds / 60); \n";
  html += "      let s = totalSeconds % 60;\n";
  html += "      return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;\n";
  html += "  }\n";
  html += "  let totalSeconds = Math.round(val * 60);\n";
  html += "  if (totalSeconds >= 3600) { \n";
  html += "    let h = Math.floor(totalSeconds / 3600); \n";
  html += "    let remainingSecondsAfterHours = totalSeconds % 3600;\n";
  html += "    let m = Math.floor(remainingSecondsAfterHours / 60); \n";
  html += "    let s = remainingSecondsAfterHours % 60;\n";
  html += "    return `${h.toString()}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;\n";
  html += "  } else { \n";
  html += "    let m = Math.floor(totalSeconds / 60); \n";
  html += "    let s = totalSeconds % 60; \n";
  html += "    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; \n";
  html += "  }\n";
  html += "}\n";
  html += "function mmssToSeconds(mmss) { \n";
  html += "  if (!mmss || typeof mmss !== \"string\") return 0; \n";
  html += "  let parts = mmss.split(\":\");\n";
  html += "  if (parts.length !== 2 && parts.length !==3) return 0;\n";
  html += "  let h = 0, m = 0, s = 0;\n";
  html += "  if (parts.length === 3) {\n";
  html += "    h = parseInt(parts[0], 10); m = parseInt(parts[1], 10); s = parseInt(parts[2], 10);\n";
  html += "  } else {\n";
  html += "    m = parseInt(parts[0], 10); s = parseInt(parts[1], 10);\n";
  html += "  }\n";
  html += "  return (isNaN(h) ? 0 : h * 3600) + (isNaN(m) ? 0 : m * 60) + (isNaN(s) ? 0 : s);\n";
  html += "}\n";
  html += "function parseEventDate(eventRow) {\n";
  html += "  if (!eventRow || eventRow.length < 2) return new Date(0); \n";
  html += "  try {\n";
  html += "    let [d, m, y] = eventRow[0].split('/').map(Number); let [hh, mm, ss] = eventRow[1].split(':').map(Number);\n";
  html += "    if (isNaN(d) || isNaN(m) || isNaN(y) || isNaN(hh) || isNaN(mm) || isNaN(ss)) return new Date(0);\n";
  html += "    return new Date(Date.UTC(y, m - 1, d, hh, mm, ss));\n";
  html += "  } catch (e) { console.error('Error parsing date for eventRow:', eventRow, e); return new Date(0); }\n";
  html += "}\n";
  html += "function toDatetimeLocal(dt) {\n";
  html += "  if (!(dt instanceof Date) || isNaN(dt)) dt = new Date(); \n";
  html += "  try {\n";
  html += "    const timezoneOffset = dt.getTimezoneOffset() * 60000; const localDate = new Date(dt.getTime() - timezoneOffset);\n";
  html += "    const pad = n => n < 10 ? '0' + n : n;\n";
  html += "    return localDate.getFullYear() + '-' + pad(localDate.getMonth() + 1) + '-' + pad(localDate.getDate()) + 'T' + pad(localDate.getHours()) + ':' + pad(localDate.getMinutes());\n";
  html += "  } catch (e) {\n";
  html += "    console.error('Error in toDatetimeLocal:', e, 'Input date:', dt);\n";
  html += "    const now = new Date(Date.now() - (new Date().getTimezoneOffset() * 60000)); return now.toISOString().slice(0, 16);\n";
  html += "  }\n";
  html += "}\n";
  html += "\n";
  html += "// --- Global Variables ---\n";
  html += "let asset = '';\n";
  html += "try {\n";
  html += "  asset = decodeURIComponent(new URLSearchParams(window.location.search).get(\"asset\") || \"\");\n";
  html += "  const assetNameElement = document.getElementById('assetNameInHeader');\n";
  html += "  if (assetNameElement) assetNameElement.textContent = asset;\n";
  html += "} catch (e) { console.error('Error getting asset from URL:', e); }\n";
  html += "\n";
  html += "let allEvents = []; let eventChart = null; let filteredEventsGlobal = []; \n";
  html += "\n";
  html += "// --- Core Logic ---\n";
  html += "function fetchAnalyticsData() {\n";
  html += "  if (!asset) {\n";
  html += "    console.warn('No asset specified, aborting fetch.');\n";
  html += "    const kpiDiv = document.getElementById('kpiMetrics');\n";
  html += "    if (kpiDiv) kpiDiv.innerHTML = \"<div class='metric'>No asset specified. Add ?asset=YourAssetName to URL.</div>\";\n";
  html += "    return;\n";
  html += "  }\n";
  html += "  \n";
  html += "fetch('/api/events')\n";
  html += "  .then(response => { if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); return response.json(); })\n";
  html += "  .then(rawEvents => {\n";
  html += "    if (!Array.isArray(rawEvents)) { \n";
  html += "      console.error('Fetched data is not an array:', rawEvents); \n";
  html += "      allEvents = []; \n";
  html += "    } else {\n";
  html += "      allEvents = rawEvents\n";
  html += "        .filter(eventRow => \n";
  html += "          eventRow.length > 13 &&\n";
  html += "          eventRow[2] &&\n";
  html += "          normalizeAssetName(eventRow[2]) === normalizeAssetName(asset)\n";
  html += "        );\n";
  html += "    }\n";
  html += "    if (allEvents.length === 0) {\n";
  html += "      const kpiDiv = document.getElementById('kpiMetrics');\n";
  html += "      if (kpiDiv) kpiDiv.innerHTML = `<div class='metric'>No data found for asset: ${asset}</div>`;\n";
  html += "    }\n";
  html += "    setupRangePickers(); \n";
  html += "    renderEventChart(); \n";
  html += "    renderRecentEvents();\n";
  html += "  });\n";
  html += "\n";
  html += "function setupRangePickers() {\n";
  html += "  let defaultFromDate, defaultToDate;\n";
  html += "  if (allEvents.length > 0) {\n";
  html += "    try {\n";
  html += "      let eventDates = allEvents.map(e => parseEventDate(e)).filter(d => d.getTime() !== 0); \n";
  html += "      if (eventDates.length > 0) {\n";
  html += "        defaultToDate = new Date(Math.max.apply(null, eventDates)); defaultFromDate = new Date(defaultToDate.getTime() - 12 * 60 * 60 * 1000); \n";
  html += "      } else { defaultToDate = new Date(); defaultFromDate = new Date(defaultToDate.getTime() - 12 * 60 * 60 * 1000); }\n";
  html += "    } catch (e) { defaultToDate = new Date(); defaultFromDate = new Date(defaultToDate.getTime() - 12 * 60 * 60 * 1000); }\n";
  html += "  } else { defaultToDate = new Date(); defaultFromDate = new Date(defaultToDate.getTime() - 12 * 60 * 60 * 1000); }\n";
  html += "  document.getElementById('fromTime').value = toDatetimeLocal(defaultFromDate);\n";
  html += "  document.getElementById('toTime').value = toDatetimeLocal(defaultToDate);\n";
  html += "  ['fromTime', 'toTime', 'showStart', 'showStop', 'showMTBF', 'showMTTR'].forEach(id => {\n";
  html += "    const el = document.getElementById(id); if (el) el.onchange = renderEventChart;\n";
  html += "  });\n";
  html += "  const exportButton = document.getElementById('exportPng');\n";
  html += "  if (exportButton) {\n";
  html += "    exportButton.onclick = function () {\n";
  html += "      if (!eventChart) { console.warn('Export PNG: Chart not ready.'); return; }\n";
  html += "      try { let url = eventChart.toBase64Image(); let a = document.createElement('a'); a.href = url; a.download = `analytics_${asset}.png`; a.click(); }\n";
  html += "      catch (e) { console.error('Error exporting chart to PNG:', e); }\n";
  html += "    };\n";
  html += "  }\n";
  html += "}\n";
  html += "function renderKPIs(currentFilteredEventsArray) {\n";
  html += "  const kpiDiv = document.getElementById('kpiMetrics'); if (!kpiDiv) return;\n";
  html += "  if (!currentFilteredEventsArray || currentFilteredEventsArray.length === 0) { kpiDiv.innerHTML = \"<div class='metric'>No data for selected range</div>\"; return; }\n";
  html += "  try {\n";
  html += "    const latestEvent = currentFilteredEventsArray[currentFilteredEventsArray.length - 1];\n";
  html += "    kpiDiv.innerHTML =\n";
  html += "      `<div class='metric'>Stops: <b>${latestEvent[10]}</b></div>\n";
  html += "       <div class='metric'>Runtime: <b>${floatMinToMMSS(latestEvent[6])}</b></div>\n";
  html += "       <div class='metric'>Downtime: <b>${floatMinToMMSS(latestEvent[7])}</b></div>\n";
  html += "       <div class='metric'>Availability: <b>${parseFloat(latestEvent[5]).toFixed(2)}%</b></div>\n";
  html += "       <div class='metric'>MTBF: <b>${floatMinToMMSS(latestEvent[8])}</b></div>\n";
  html += "       <div class='metric'>MTTR: <b>${floatMinToMMSS(latestEvent[9])}</b></div>`;\n";
  html += "  } catch (e) { console.error('Error rendering KPIs:', e); kpiDiv.innerHTML = \"<div class='metric'>Error rendering KPIs</div>\"; }\n";
  html += "}\n";
  html += "function renderEventChart() {\n";
  html += "  if (!allEvents || allEvents.length === 0) { if (eventChart) { eventChart.destroy(); eventChart = null; } return; }\n";
  html += "  let fromDate, toDate;\n";
  html += "  try { fromDate = new Date(document.getElementById('fromTime').value); toDate = new Date(document.getElementById('toTime').value); }\n";
  html += "  catch (e) { console.error('Error parsing date/time input values:', e); return; }\n";
  html += "  const showStart = document.getElementById('showStart').checked; const showStop = document.getElementById('showStop').checked;\n";
  html += "  const showMTBF = document.getElementById('showMTBF').checked; const showMTTR = document.getElementById('showMTTR').checked;\n";
  html += "  \n";
  html += "  filteredEventsGlobal = allEvents.filter(eventRow => {\n";
  html += "    try {\n";
  html += "      const eventDate = parseEventDate(eventRow); if (eventDate.getTime() === 0) return false; \n";
  html += "      if (eventDate < fromDate || eventDate > toDate) return false; if (!eventRow[3]) return false; \n";
  html += "      if (eventRow[3].trim().toUpperCase() === \"START\" && !showStart) return false;\n";
  html += "      if (eventRow[3].trim().toUpperCase() === \"STOP\" && !showStop) return false; return true;\n";
  html += "    } catch (e) { return false; }\n";
  html += "  });\n";
  html += "  renderKPIs(filteredEventsGlobal); \n";
  html += "  if (filteredEventsGlobal.length === 0) { if (eventChart) { eventChart.destroy(); eventChart = null; } return; }\n";
  html += "\n";
  html += "  try {\n";
  html += "    let times = filteredEventsGlobal.map(e => e[1]); \n";
  html += "    let avail = filteredEventsGlobal.map(e => parseFloat(e[5]));\n";
  html += "    let mtbfValues = filteredEventsGlobal.map(e => parseFloat(e[8])); \n";
  html += "    let mttrValues = filteredEventsGlobal.map(e => parseFloat(e[9]));\n";
  html += "    let stateArr = filteredEventsGlobal.map(e => e[4] ? e[4].trim() : 'UNKNOWN_STATE'); \n";
  html += "    \n";
  html += "    let pointColors = filteredEventsGlobal.map((e, index, arr) => {\n";
  html += "      const eventType = e[3] ? e[3].trim().toUpperCase() : \"\";\n";
  html += "      let durationForStopDecision = \"0:0\";\n";
  html += "      if (eventType === \"STOP\") {\n";
  html += "        if (index + 1 < arr.length) { \n";
  html += "          const nextEvent = arr[index + 1];\n";
  html += "          const nextEventType = nextEvent[3] ? nextEvent[3].trim().toUpperCase() : \"\";\n";
  html += "          if (nextEventType === \"START\") { durationForStopDecision = nextEvent[12] || \"0:0\"; } \n";
  html += "          else { durationForStopDecision = e[12] || \"0:0\"; }\n";
  html += "        } else { durationForStopDecision = e[12] || \"0:0\"; }\n";
  html += "      }\n";
  html += "      if (eventType === \"STOP\" && mmssToSeconds(durationForStopDecision) >= 300) return \"#c62828\"; \n";
  html += "      if (eventType === \"STOP\") return \"#ff9800\"; \n";
  html += "      return \"#43a047\"; \n";
  html += "    });\n";
  html += "\n";
  html += "    let pointSizes = filteredEventsGlobal.map((e, index, arr) => {\n";
  html += "       const eventType = e[3] ? e[3].trim().toUpperCase() : \"\";\n";
  html += "       let durationForStopDecision = \"0:0\";\n";
  html += "       if (eventType === \"STOP\") {\n";
  html += "         if (index + 1 < arr.length) {\n";
  html += "           const nextEvent = arr[index + 1];\n";
  html += "           const nextEventType = nextEvent[3] ? nextEvent[3].trim().toUpperCase() : \"\";\n";
  html += "           if (nextEventType === \"START\") { durationForStopDecision = nextEvent[12] || \"0:0\"; } \n";
  html += "           else { durationForStopDecision = e[12] || \"0:0\"; }\n";
  html += "         } else { durationForStopDecision = e[12] || \"0:0\"; }\n";
  html += "       }\n";
  html += "      let defaultSize = 7;\n";
  html += "      if (eventType === \"STOP\" && mmssToSeconds(durationForStopDecision) >= 300) { defaultSize = 12; }\n";
  html += "      return defaultSize;\n";
  html += "    });\n";
  html += "\n";
  html += "    let datasets = [{\n";
  html += "      label: 'Availability (%)', data: avail, yAxisID: 'y', stepped: true, tension: 0,\n";
  html += "      pointRadius: pointSizes, pointBackgroundColor: pointColors, pointBorderColor: pointColors, showLine: true,\n";
  html += "      segment: {\n";
  html += "        borderColor: ctx => {\n";
  html += "          const stateValue = stateArr[ctx.p0DataIndex];\n";
  html += "          if (stateValue === \"1\") return \"#43a047\"; if (stateValue === \"0\") return \"#c62828\"; \n";
  html += "          return \"#000000\"; \n";
  html += "        },\n";
  html += "        borderWidth: 3\n";
  html += "      }\n";
  html += "    }];\n";
  html += "    if (showMTBF) datasets.push({ label: 'MTBF', data: mtbfValues, yAxisID: 'y1', borderColor: \"#1565c0\", borderWidth: 2, tension: 0, pointRadius: 4 });\n";
  html += "    if (showMTTR) datasets.push({ label: 'MTTR', data: mttrValues, yAxisID: 'y1', borderColor: \"#FFD600\", borderWidth: 2, tension: 0, pointRadius: 4 });\n";
  html += "    \n";
  html += "    if (eventChart) eventChart.destroy();\n";
  html += "    const ctx = document.getElementById('eventChart').getContext('2d');\n";
  html += "    eventChart = new Chart(ctx, {\n";
  html += "      type: 'line', data: { labels: times, datasets: datasets },\n";
  html += "      options: {\n";
  html += "        responsive: true, maintainAspectRatio: false,\n";
  html += "        interaction: { mode: 'nearest', axis: 'x', intersect: true }, \n";
  html += "        layout: { padding: { top: 15 }},\n";
  html += "        plugins: {\n";
  html += "          tooltip: {\n";
  html += "            callbacks: {\n";
  html += "              title: (tooltipItems) => {\n";
  html += "                if (!tooltipItems.length) return ''; \n";
  html += "                const idx = tooltipItems[0].dataIndex;\n";
  html += "                if (!filteredEventsGlobal[idx]) return 'Error: No data for this point.';\n";
  html += "                return `Event: ${filteredEventsGlobal[idx][3]} at ${filteredEventsGlobal[idx][0]} ${filteredEventsGlobal[idx][1]}`;\n";
  html += "              },\n";
  html += "              label: (tooltipItem) => {\n";
  html += "                const idx = tooltipItem.dataIndex;\n";
  html += "                const eventRow = filteredEventsGlobal[idx];\n";
  html += "                const eventType = eventRow[3] ? eventRow[3].trim().toUpperCase() : \"\";\n";
  html += "                const datasetLabel = tooltipItem.dataset.label || '';\n";
  html += "                let lines = [];\n";
  html += "\n";
  html += "                if (datasetLabel === 'Availability (%)') {\n";
  html += "                  const currentAvail = parseFloat(eventRow[5]).toFixed(2);\n";
  html += "                  lines.push(`Availability: ${currentAvail}%`);\n";
  html += "                  if (eventType === \"START\") {\n";
  html += "                    const stopDurationSeconds = mmssToSeconds(eventRow[12] || \"0:0\");\n";
  html += "                    if (stopDurationSeconds > 0) {\n";
  html += "                         lines.push(`(Prior Stop: ${floatMinToMMSS(stopDurationSeconds / 60.0)})`);\n";
  html += "                    }\n";
  html += "                  } else if (eventType === \"STOP\") {\n";
  html += "                    const runDurationSeconds = mmssToSeconds(eventRow[11] || \"0:0\");\n";
  html += "                    if (runDurationSeconds > 0) {\n";
  html += "                        lines.push(`(Prior Run: ${floatMinToMMSS(runDurationSeconds / 60.0)})`);\n";
  html += "                    }\n";
  html += "                  }\n";
  html += "                } else if (datasetLabel === 'MTBF' || datasetLabel === 'MTTR') {\n";
  html += "                  const currentValue = tooltipItem.raw;\n";
  html += "                  const formattedCurrentValue = floatMinToMMSS(currentValue);\n";
  html += "                  lines.push(`${datasetLabel}: ${formattedCurrentValue}`);\n";
  html += "\n";
  html += "                  if (idx > 0) {\n";
  html += "                    const previousValue = tooltipItem.dataset.data[idx - 1];\n";
  html += "                    if (typeof previousValue === 'number' && typeof currentValue === 'number') {\n";
  html += "                        const change = currentValue - previousValue;\n";
  html += "                        if (Math.abs(change) > 1e-7) {\n";
  html += "                            const formattedChange = floatMinToMMSS(Math.abs(change));\n";
  html += "                            let changeIndicator = \"\";\n";
  html += "                            if (datasetLabel === 'MTBF') {\n";
  html += "                                changeIndicator = change > 0 ? `(Increased by ${formattedChange} - Good)` : `(Decreased by ${formattedChange} - Bad)`;\n";
  html += "                            } else {\n";
  html += "                                changeIndicator = change > 0 ? `(Increased by ${formattedChange} - Bad)` : `(Decreased by ${formattedChange} - Good)`;\n";
  html += "                            }\n";
  html += "                            lines.push(changeIndicator);\n";
  html += "                        } else {\n";
  html += "                            lines.push(`(No significant change)`);\n";
  html += "                        }\n";
  html += "                    }\n";
  html += "                  } else {\n";
  html += "                    lines.push(`(Initial value)`);\n";
  html += "                  }\n";
  html += "\n";
  html += "                  if (datasetLabel === 'MTBF' && eventType === \"STOP\") {\n";
  html += "                    const lastRunDurationSeconds = mmssToSeconds(eventRow[11] || \"0:0\");\n";
  html += "                    if (lastRunDurationSeconds > 0) {\n";
  html += "                      lines.push(`(Influenced by last run: ${floatMinToMMSS(lastRunDurationSeconds / 60.0)})`);\n";
  html += "                    }\n";
  html += "                  } else if (datasetLabel === 'MTTR' && eventType === \"START\") {\n";
  html += "                    const lastStopDurationSeconds = mmssToSeconds(eventRow[12] || \"0:0\");\n";
  html += "                    if (lastStopDurationSeconds > 0) {\n";
  html += "                      lines.push(`(Influenced by last stop: ${floatMinToMMSS(lastStopDurationSeconds / 60.0)})`);\n";
  html += "                    }\n";
  html += "                  }\n";
  html += "                }\n";
  html += "                return lines.length > 0 ? lines : null;\n";
  html += "              }\n";
  html += "            }\n";
  html += "          },\n";
  html += "          legend: { position: 'top' }\n";
  html += "        },\n";
  html += "        scales: {\n";
  html += "          x: { title: { display: true, text: 'Time (HH:MM:SS)' } },\n";
  html += "          y: { \n";
  html += "            title: { display: true, text: 'Availability (%)' }, \n";
  html += "            beginAtZero: true, \n";
  html += "            suggestedMax: 105, \n";
  html += "            ticks: {\n";
  html += "                stepSize: 20,    \n";
  html += "                callback: function(value, index, values) {\n";
  html += "                    if (value > 100) return undefined; \n";
  html += "                    if (value === 100) return 100;\n";
  html += "                    if (value < 100 && value >= 0 && (value % (this.chart.options.scales.y.ticks.stepSize || 20) === 0) ) return value;\n";
  html += "                    return undefined; \n";
  html += "                }\n";
  html += "            }\n";
  html += "          }, \n";
  html += "          y1: { type: 'linear', display: true, position: 'right', title: { display: true, text: 'MTBF/MTTR' }, beginAtZero: true, grid: { drawOnChartArea: false }, ticks: { callback: val => floatMinToMMSS(val) } }\n";
  html += "        }\n";
  html += "      }\n";
  html += "    });\n";
  html += "  } catch (e) { console.error('Error rendering chart:', e); }\n";
  html += "}\n";
  html += "function renderRecentEvents() {\n";
  html += "  const tbody = document.getElementById('recentEvents'); if (!tbody) return; tbody.innerHTML = \"\"; \n";
  html += "  if (!allEvents || allEvents.length === 0) { tbody.innerHTML = \"<tr><td colspan='13'>No event data for this asset.</td></tr>\"; return; }\n";
  html += "  const eventsToDisplay = allEvents.slice(-10).reverse(); \n";
  html += "  if (eventsToDisplay.length === 0) { tbody.innerHTML = \"<tr><td colspan='13'>No recent events for this asset.</td></tr>\"; return; }\n";
  html += "  eventsToDisplay.forEach(eventRow => {\n";
  html += "    try {\n";
  html += "      if (eventRow.length < 14) { \n";
  html += "          let tr = tbody.insertRow(); let td = tr.insertCell(); td.colSpan = 13; \n";
  html += "          td.textContent = \"Malformed data.\"; td.style.color = \"orange\"; return; \n";
  html += "      }\n";
  html += "      let tr = tbody.insertRow();\n";
  html += "      tr.insertCell().textContent = eventRow[0];  tr.insertCell().textContent = eventRow[1];  \n";
  html += "      tr.insertCell().textContent = eventRow[2];  tr.insertCell().textContent = eventRow[3];  \n";
  html += "      tr.insertCell().textContent = parseFloat(eventRow[5]).toFixed(2); \n";
  html += "      tr.insertCell().textContent = floatMinToMMSS(eventRow[6]); \n";
  html += "      tr.insertCell().textContent = floatMinToMMSS(eventRow[7]); \n";
  html += "      tr.insertCell().textContent = floatMinToMMSS(eventRow[8]); \n";
  html += "      tr.insertCell().textContent = floatMinToMMSS(eventRow[9]);\n";
  html += "      tr.insertCell().textContent = eventRow[10]; \n";
  html += "      tr.insertCell().textContent = floatMinToMMSS(mmssToSeconds(eventRow[11] || \"0:0\") / 60.0); \n";
  html += "      tr.insertCell().textContent = floatMinToMMSS(mmssToSeconds(eventRow[12] || \"0:0\") / 60.0); \n";
  html += "      tr.insertCell().textContent = eventRow[13] || \"\"; \n";
  html += "    } catch (e) {\n";
  html += "      console.error('Error rendering row for event:', eventRow, e);\n";
  html += "      let tr = tbody.insertRow(); let td = tr.insertCell(); td.colSpan = 13; \n";
  html += "      td.textContent = \"Error displaying row.\"; td.style.color = \"red\";\n";
  html += "    }\n";
  html += "  });\n";
  html += "}\n";
  html += "// --- Initialisation ---\n";
  html += "if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', fetchAnalyticsData); }\n";
  html += "else { fetchAnalyticsData(); }\n";
  html += "</script>";
  html += "</div></body></html>";
  return html;
}

String htmlAnalyticsCompare() {
  String html = "<!DOCTYPE html><html lang='en'><head><title>Compare Assets</title>";
  html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<link href='https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap' rel='stylesheet'>";
  html += "<script src='https://cdn.jsdelivr.net/npm/chart.js'></script>";
  html += "<style>";
  html += "body{font-family:Roboto,sans-serif;background:#f3f7fa;margin:0;}";
  html += "header{background:#1976d2;color:#fff;padding:1.3rem 0;text-align:center;box-shadow:0 2px 10px #0001; font-size:1.6em; font-weight:700;}";
  html += ".nav{display:flex;justify-content:center;gap:1rem;margin:1rem 0;flex-wrap:wrap;}";
  html += ".nav a, .nav button {text-decoration:none;background:#fff;color:#1976d2;border:none;border-radius:6px;padding:0.7em 1.1em;font-size:1.1em;font-weight:700;box-shadow:0 2px 8px #0001;cursor:pointer;}";
  html += ".nav a:hover, .nav button:hover {background:#e3f0fc;}";
  html += ".main{max-width:1100px;margin:1rem auto;padding:1rem;}";
  html += ".card{background:#fff;border-radius:10px;box-shadow:0 2px 16px #0002;margin-bottom:1.3rem;padding:1.3rem;}";
  html += ".flexrow{display:flex;flex-wrap:wrap;gap:2em;justify-content:center;}";
  html += ".chartcard{flex:1 1 320px;min-width:300px; max-width: calc(50% - 1em);}"; // Ensures two charts per row on larger screens
  html += ".tablecard{overflow-x:auto;width:100%;}";
  html += "th, td { text-align: left !important; padding:0.5em;}"; // Ensure table text alignment
  html += "table{width:100%; border-collapse:collapse;} th{background:#e3f0fc;color:#1976d2;} tr:nth-child(even){background:#f8f9fa;}";
  html += "@media(max-width:700px){.flexrow{flex-direction:column;gap:1em;}.chartcard{max-width:100%;}.card{padding:0.7em;}}";
  html += "</style></head><body>";
  html += "<header>Compare Assets</header>";
  html += "<nav class='nav'>";
  html += "<a href='/'>Dashboard</a>";
  html += "<a href='/events'>Event Log</a>";
  html += "<a href='/export_log'>Export CSV</a>"; // Changed from button to link
  html += "</nav>";
  html += "<div class='main'>";
  html += "<div class='flexrow'>";
  html += "<div class='card chartcard'><canvas id='barAvail'></canvas></div>";
  html += "<div class='card chartcard'><canvas id='barStops'></canvas></div>";
  html += "<div class='card chartcard'><canvas id='barMTBF'></canvas></div>";
  html += "<div class='card chartcard'><canvas id='pieReasons'></canvas></div>";
  html += "</div>";
  html += "<div class='card tablecard'>";
  html += "<h3>Last Event Log Summary</h3><table style='width:100%;'><thead><tr>"
          "<th>Asset</th>"
          "<th>Availability (%)</th>"
          "<th>Runtime</th>"
          "<th>Downtime</th>"
          "<th>Stops</th>"
          "<th>MTBF</th>"
          "<th>MTTR</th>"
          "</tr></thead><tbody id='compareTable'></tbody></table></div>";
  html += "<script>";
  html += R"rawliteral(
let allEventsCompare = [], allAssetNamesCompare = [], configDowntimeReasonsCompare = []; 
function formatMinutesToHHMMSSCompare(val) { 
  if (isNaN(val) || val <= 0.001) return "0:00:00"; 
  let totalSeconds = Math.round(val * 60);
  let h = Math.floor(totalSeconds / 3600); let m = Math.floor((totalSeconds % 3600) / 60); let s = totalSeconds % 60;
  return h.toString().padStart(1, '0') + ":" + m.toString().padStart(2, '0') + ":" + s.toString().padStart(2, '0'); 
}
function fetchCompareDataPage() { 
  fetch('/api/config').then(r=>r.json()).then(cfg=>{
    configDowntimeReasonsCompare = cfg.downtimeReasons||[]; allAssetNamesCompare = cfg.assets.map(a=>a.name);
    fetch('/api/events').then(r=>r.json()).then(events=>{ // Assuming /api/events returns JSON array of arrays
      allEventsCompare = events.map(l=>(typeof l === 'string' ? l.split(',') : (Array.isArray(l) ? l : []))).filter(v=>v.length>13 && allAssetNamesCompare.includes(v[2]));
      renderCompareChartsPage(); renderCompareTablePage();
    }).catch(e=>console.error("CompareEventsFetchErr:", e));
  }).catch(e=>console.error("CompareConfigFetchErr:", e));
}
function getLastMetricCompare(events, idx) { return events && events.length ? parseFloat(events[events.length-1][idx]) : 0; }
function renderCompareChartsPage() { 
  let byAsset = {}; allAssetNamesCompare.forEach(a=>{byAsset[a]=[];});
  for (let e of allEventsCompare) { if(byAsset[e[2]]) byAsset[e[2]].push(e); } 
  let labels = allAssetNamesCompare;
  let avail = labels.map(a=>getLastMetricCompare(byAsset[a]||[],5)); 
  let stops = labels.map(a=>(byAsset[a]||[]).filter(e=>e[3] && e[3].toUpperCase()==="STOP").length); 
  let mtbf = labels.map(a=>getLastMetricCompare(byAsset[a]||[],8));
  let reasons = {}; configDowntimeReasonsCompare.forEach(r => reasons[r] = 0); 
  for (let e of allEventsCompare) {
    if (e.length < 14) continue; let note = e[13]||""; let res = "";
    if (note.indexOf(" - ")>-1) res = note.split(" - ")[0].trim(); else res = note.trim();
    if (res && configDowntimeReasonsCompare.includes(res)) reasons[res] = (reasons[res]||0)+1;
  }
  const pieLabels = Object.keys(reasons).filter(r => reasons[r] > 0);
  const pieData = pieLabels.map(r => reasons[r]);
  const pieColors = ['#ffa726','#ef5350','#66bb6a','#42a5f5','#ab47bc', '#FFEE58', '#26A69A', '#78909C'];
  ['barAvail', 'barStops', 'barMTBF', 'pieReasons'].forEach(id => { const c = document.getElementById(id); if (c && c.chartInstance) c.chartInstance.destroy(); });
  if (document.getElementById('barAvail')) { document.getElementById('barAvail').chartInstance = new Chart(document.getElementById('barAvail').getContext('2d'), { type:'bar',data:{labels:labels,datasets:[{label:'Availability (%)',data:avail,backgroundColor:'#42a5f5'}]},options:{scales:{y:{beginAtZero:true,max:100}}}}); }
  if (document.getElementById('barStops')) { document.getElementById('barStops').chartInstance = new Chart(document.getElementById('barStops').getContext('2d'), { type:'bar',data:{labels:labels,datasets:[{label:'Total Stops',data:stops,backgroundColor:'#ef5350'}]},options:{scales:{y:{beginAtZero:true}}}}); }
  if (document.getElementById('barMTBF')) { document.getElementById('barMTBF').chartInstance = new Chart(document.getElementById('barMTBF').getContext('2d'), { type:'bar',data:{labels:labels,datasets:[{label:'MTBF (min)',data:mtbf,backgroundColor:'#66bb6a'}]},options:{scales:{y:{beginAtZero:true}}}}); }
  const pc = document.getElementById('pieReasons');
  if (pc) { if (pieLabels.length > 0) { pc.chartInstance = new Chart(pc.getContext('2d'), { type:'pie',data:{ labels:pieLabels,datasets:[{data:pieData,backgroundColor:pieColors.slice(0, pieLabels.length)}]}}); } else { pc.getContext('2d').fillText("No reason data.", pc.width/2, pc.height/2);}}
}
function renderCompareTablePage() { 
  let tb = document.getElementById('compareTable'); if(!tb) return; tb.innerHTML = "";
  let byAsset = {}; allAssetNamesCompare.forEach(a=>{byAsset[a]=[];});
  for (let e of allEventsCompare) { if(byAsset[e[2]]) byAsset[e[2]].push(e); }
  for (let a of allAssetNamesCompare) {
    let evs = byAsset[a]||[], e_last = evs.length?evs[evs.length-1]:null; 
    tb.innerHTML += `<tr><td>${a}</td><td>${e_last&&e_last[5]?parseFloat(e_last[5]).toFixed(2):"-"}</td><td>${e_last&&e_last[6]?formatMinutesToHHMMSSCompare(parseFloat(e_last[6])):"-"}</td><td>${e_last&&e_last[7]?formatMinutesToHHMMSSCompare(parseFloat(e_last[7])):"-"}</td><td>${e_last&&e_last[10]?e_last[10]:"-"}</td><td>${e_last&&e_last[8]?formatMinutesToHHMMSSCompare(parseFloat(e_last[8])):"-"}</td><td>${e_last&&e_last[9]?formatMinutesToHHMMSSCompare(parseFloat(e_last[9])):"-"}</td></tr>`;
  }
}
if(document.readyState==='loading'){document.addEventListener('DOMContentLoaded',fetchCompareDataPage);}else{fetchCompareDataPage();}
)rawliteral";
  html += "</script>";
  html += "</div></body></html>";
  return html;
}

// sendHtmlEventsPage - from your V21
void sendHtmlEventsPage() {
  server.setContentLength(CONTENT_LENGTH_UNKNOWN);
  server.send(200, "text/html", "");

  server.sendContent("<!DOCTYPE html><html lang='en'><head><title>Event Log</title>");
  server.sendContent("<meta name='viewport' content='width=device-width,initial-scale=1'>");
  server.sendContent("<link href='https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap' rel='stylesheet'>");
  server.sendContent("<style>");
  server.sendContent("body{font-family:Roboto,sans-serif;background:#f3f7fa;margin:0;}header{background:#1976d2;color:#fff;padding:1.2rem 0;text-align:center;box-shadow:0 2px 10px #0001; font-size:1.6em;font-weight:700;}");
  server.sendContent(".nav{display:flex;justify-content:center;gap:1rem;margin:1rem 0 0 0;flex-wrap:wrap;}");
  server.sendContent(".nav button, .nav a {text-decoration:none;background:#fff;color:#1976d2;border:none;border-radius:6px;padding:0.7em 1.1em;font-size:1.1em;font-weight:700;box-shadow:0 2px 8px #0001;cursor:pointer;}");
  server.sendContent(".nav button:hover, .nav a:hover {background:#e3f0fc;}");
  server.sendContent(".main{max-width:1300px;margin:1rem auto;padding:1rem;}");
  server.sendContent(".card{background:#fff;border-radius:10px;box-shadow:0 2px 16px #0002;margin-bottom:1.3rem;padding:1.3rem;}");
  server.sendContent(".filterrow{display:flex;gap:1em;align-items:center;margin-bottom:1em;flex-wrap:wrap;}");
  server.sendContent(".filterrow label{font-weight:bold; margin-right:0.3em;} .filterrow select, .filterrow input {padding:0.5em; border-radius:4px; border:1px solid #ccc; margin-right:1em;}");
  server.sendContent(".scrollToggle{margin-left:auto;font-size:1em; padding: 0.5em 0.8em; border-radius:4px; background-color:#6c757d; color:white; border:none; cursor:pointer;} .scrollToggle:hover{background-color:#5a6268;}");
  server.sendContent("table{width:100%;border-collapse:collapse;font-size:1em;margin-top:0.8em;}");
  server.sendContent("th,td{padding:0.7em 0.5em;text-align:left;border-bottom:1px solid #eee;}");
  server.sendContent("th{background:#2196f3;color:#fff;}");
  server.sendContent("tr{background:#fcfcfd;} tr:nth-child(even){background:#f3f7fa;}");
  server.sendContent(".note{font-style:italic;color:#555;white-space:normal;word-break:break-word;display:inline-block;max-width:200px;vertical-align:middle;}");
  server.sendContent(".notebtn{padding:4px 8px;font-size:0.9em;border-radius:4px;background:#1976d2;color:#fff;border:none;cursor:pointer;margin-left:5px;white-space:nowrap;vertical-align:middle;} .notebtn:hover{background:#1565c0;}");
  server.sendContent("td:last-child{min-width:220px;overflow-wrap:anywhere;word-break:break-word;}");
  server.sendContent(".modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.5);display:none;justify-content:center;align-items:center;z-index:1000;}");
  server.sendContent(".modal-content{background-color:#fff;padding:20px;border-radius:8px;box-shadow:0 4px 15px rgba(0,0,0,0.2);width:90%;max-width:450px;display:flex;flex-direction:column;}");
  server.sendContent(".modal-title{margin-top:0;color:#1976d2;}");
  server.sendContent(".modal-content label{margin-top:10px;margin-bottom:3px;font-weight:bold;}");
  server.sendContent(".modal-content select, .modal-content input[type=\"text\"]{width:100%;padding:8px;margin-bottom:10px;border:1px solid #ccc;border-radius:4px;box-sizing:border-box;}");
  server.sendContent(".modal-actions{margin-top:15px;display:flex;justify-content:flex-end;gap:10px;}");
  server.sendContent(".modal-actions button{padding:8px 15px;border-radius:4px;border:none;cursor:pointer;font-weight:bold;}");
  server.sendContent(".modal-actions .btn-save{background-color:#1976d2;color:white;}");
  server.sendContent(".modal-actions .btn-cancel{background-color:#6c757d;color:white;}");
  server.sendContent("@media (max-width:700px){");
  server.sendContent("  #eventTable{display:none;}");
  server.sendContent("  .eventCard {background: #fff;border-radius: 10px;box-shadow: 0 2px 10px #0001;margin-bottom: 1.2em;padding: 1em;font-size: 1.05em;}");
  server.sendContent("  .eventCard div {margin-bottom: 0.3em;}");
  server.sendContent("  #mobileEvents {max-height:70vh;overflow-y:auto;}");
  server.sendContent("  .filterrow {flex-direction:column; align-items:stretch;} .filterrow label, .filterrow select, .filterrow input {width:100%; margin-bottom:0.5em;} .scrollToggle{margin-left:0; width:100%; text-align:center;}");
  server.sendContent("}");
  server.sendContent("@media (min-width:701px){");
  server.sendContent("  #mobileEvents{display:none;}");
  server.sendContent("}");
  server.sendContent("</style>");
  server.sendContent("<script>");
  server.sendContent(R"rawliteral(
let eventData = []; 
let channelList = []; 
let filterValue = "ALL"; 
let stateFilter = "ALL"; 
window.downtimeReasons = []; 
let scrollInhibit = false; 
window.refreshIntervalId = null;

function startAutoRefresh() {
  if (window.refreshIntervalId) clearInterval(window.refreshIntervalId);
  window.refreshIntervalId = setInterval(fetchAndRenderEvents, 5000); 
}
function stopAutoRefresh() {
  if (window.refreshIntervalId) clearInterval(window.refreshIntervalId);
  window.refreshIntervalId = null;
}

function initializeEventPage() {
  console.log("DOMContentLoaded. Initializing event page (modal version)...");
  let testSel = document.getElementById('channelFilter');
  if (!testSel) {
    console.error("!!! TEST FAIL: 'channelFilter' is NULL after DOMContentLoaded.");
    const mainCard = document.querySelector(".main.card"); 
    if(mainCard) mainCard.innerHTML = "<h1 style='color:red;'>CRITICAL DOM ERROR: 'channelFilter' not found.</h1>";
    else document.body.innerHTML = "<h1 style='color:red;'>CRITICAL DOM ERROR: 'channelFilter' not found.</h1>";
  } else {
    console.log("+++ TEST PASS: 'channelFilter' found. Proceeding.");
    fetchChannelsAndStart(); 
  }
}

function fetchChannelsAndStart() { 
  fetch('/api/summary').then(r=>r.json()).then(data=>{
    channelList = data.assets.map(a=>a.name);
    let sel = document.getElementById('channelFilter');
    if (!sel) { console.error("CRIT: 'channelFilter' null in fetchChannelsAndStart."); return; }
    sel.innerHTML = "<option value='ALL'>All Assets</option>"; 
    // --- Add SYSTEM_EVENTS_ONLY filter option ---
    sel.innerHTML += "<option value='SYSTEM_EVENTS_ONLY'>SYSTEM Events Only</option>";
    // --- End Add ---
    channelList.forEach(c => { let o=document.createElement("option"); o.value=c; o.text=c; sel.appendChild(o); });
    sel.onchange = function() { filterValue = sel.value; renderTable(); };
    
    let stateSel = document.getElementById('stateFilter');
    if (!stateSel) { console.error("CRIT: 'stateFilter' null."); return; }
    stateSel.onchange = function() { stateFilter = this.value; renderTable(); };
    
    fetchReasonsAndEvents(); 
  }).catch(e => {
      console.error("Error fetching channels/filters:", e); 
      const mc = document.querySelector(".main.card");
      if(mc) mc.innerHTML = "<p style='color:red;font-weight:bold;'>Error loading filter data.</p>";
  });
}
function fetchReasonsAndEvents() { 
  fetch('/api/config').then(r=>r.json()).then(cfg=>{
    window.downtimeReasons = cfg.downtimeReasons || [];
    fetchAndRenderEvents(); 
    startAutoRefresh(); 
  }).catch(e => console.error("Error fetching config reasons:", e));
}
function fetchAndRenderEvents() { 
  fetch('/api/events').then(r=>r.json()).then(events=>{ // Assumes /api/events sends JSON array of arrays
    eventData = events; renderTable(); 
  }).catch(e => {
      console.error("Error fetching events:", e);
      const tb = document.getElementById('tbody'); if(tb) tb.innerHTML = "<tr><td colspan='14' style='color:red;text-align:center;'>Failed to load events.</td></tr>";
      const md = document.getElementById('mobileEvents'); if(md) md.innerHTML = "<p style='color:red;text-align:center;'>Failed to load events.</p>";
  });
}
function cleanNote(val) { 
  if (!val) return ""; let v = val.trim();
  if (v === "" || v === "," || v === ",," || v === "0,0," || v === "0.00,0,") return "";
  return v.replace(/^,+|,+$/g, ""); 
}
function minToHHMMSS(valStr) { 
  let val = parseFloat(valStr); if (isNaN(val) || val <= 0.001) return "00:00:00"; 
  let s_total = Math.round(val * 60);
  let h=Math.floor(s_total/3600), m=Math.floor((s_total%3600)/60), s=s_total%60;
  return (h<10?"0":"")+h+":"+(m<10?"0":"")+m+":"+(s<10?"0":"")+s;
}
function durationStrToHHMMSS(str) { // Handles "MM:SS" from log
  if (!str || typeof str !== "string" || str.trim()==="") return ""; 
  let p=str.split(":").map(Number); let h=0,m=0,s=0;
  if(p.length===2){[m,s]=p;h=Math.floor(m/60);m%=60;}
  else if(p.length===3){[h,m,s]=p;} // If formatMMSS starts outputting H:MM:SS
  else return ""; // Invalid format
  if(isNaN(h)||isNaN(m)||isNaN(s))return ""; 
  return (h>0?(h<10?"0":"")+h+":":"")+(m<10?"0":"")+m+":"+(s<10?"0":"")+s;
}

function populateModalReasons() {
  const reasonSelect = document.getElementById('modalNoteReason');
  if (!reasonSelect) return;
  reasonSelect.innerHTML = '<option value=""></option>'; 
  (window.downtimeReasons || []).forEach(r => {
    let opt = document.createElement('option');
    opt.value = r; opt.text = r;
    reasonSelect.appendChild(opt);
  });
  // Add "Other" option
  let otherOpt = document.createElement('option'); otherOpt.value = "Other"; otherOpt.text = "Other (Specify Below)";
  reasonSelect.appendChild(otherOpt);
}

function showNoteModal(date, time, asset, currentFullNote) {
  stopAutoRefresh();
  const modal = document.getElementById('noteEditModal');
  if (!modal) { console.error("Modal not found!"); return; }

  populateModalReasons();

  document.getElementById('modalNoteDate').value = date;
  document.getElementById('modalNoteTime').value = time;
  document.getElementById('modalNoteAsset').value = asset;

  let currentReason = "";
  let currentTextNote = currentFullNote; 

  if (currentFullNote) {
    if ((window.downtimeReasons || []).includes(currentFullNote)) {
        currentReason = currentFullNote;
        currentTextNote = "";
    } else {
        for (const reason of (window.downtimeReasons || [])) {
            if (currentFullNote.startsWith(reason + " - ")) {
                currentReason = reason;
                currentTextNote = currentFullNote.substring(reason.length + " - ".length);
                break; 
            }
        }
        // If no standard reason was prefixed, and there's a note, it's "Other"
        if (!currentReason && currentTextNote.trim() !== "") {
             // currentReason remains empty, or set to "Other" if "Other" is an explicit choice
        }
    }
  }
  
  const reasonDropdown = document.getElementById('modalNoteReason');
  if (reasonDropdown) reasonDropdown.value = currentReason; // Select the reason if found
  document.getElementById('modalNoteText').value = currentTextNote;
  
  modal.style.display = 'flex';
}

function hideNoteModal() {
  const modal = document.getElementById('noteEditModal');
  if (modal) modal.style.display = 'none';
  startAutoRefresh();
}

function submitModalNote(event) {
  event.preventDefault();
  const form = document.getElementById('modalNoteForm');
  const params = new URLSearchParams();
  params.append('date', form.date.value);
  params.append('time', form.time.value);
  params.append('asset', form.asset.value);
  params.append('reason', form.reason.value); 
  params.append('note', form.note.value); 

  fetch('/api/note', { // Ensure this matches your server endpoint
    method: 'POST',
    headers: {'Content-Type':'application/x-www-form-urlencoded'},
    body: params.toString()
  }).then(r => {
    if (r.ok) { fetchAndRenderEvents(); } 
    else { alert("Failed to save note. Status: " + r.status); }
  }).catch(err => { console.error("Error saving note:", err); alert("Error saving note."); });
  
  hideNoteModal();
  return false;
}

function normalizeAssetName(name) {
    return (name || '').toLowerCase().replace(/\s+/g, '');
}

function renderTable() {
    let tbody = document.getElementById('tbody');
    let mobileDiv = document.getElementById('mobileEvents');
    if (!tbody || !mobileDiv) { console.error("Table/mobile div not found"); return; }

    tbody.innerHTML = '';
    mobileDiv.innerHTML = '';
    let stateMatcher = (sVal) =>
        (stateFilter === "ALL") ||
        (stateFilter === "RUNNING" && sVal === "1") ||
        (stateFilter === "STOPPED" && sVal === "0");
    let isMobile = window.innerWidth <= 700;
    let displayData = eventData.slice().reverse();

    for (let i = 0; i < displayData.length; ++i) {
        let vals = displayData[i];
        if (!Array.isArray(vals) || vals.length < 13) continue;

        // Defensive: Some API rows have 13, some 14 columns
        let [ldate, ltime, lasset, levent, lstateVal, lavail, lrun, lstop, lmtbf, lmttr, lsc, runDurStr, stopDurStr] = vals;
        let lnote = vals.length > 13 ? vals.slice(13).join(',').replace(/\n$/, "") : "";

        let stopsInt = Math.round(Number(lsc));

        // SYSTEM_EVENTS_ONLY filter
        let isSystemEvent = (levent === "SYS_START" || levent === "SYS_STOP");
        if (filterValue === "SYSTEM_EVENTS_ONLY" && !isSystemEvent) continue;

        // Fuzzy asset name filter
        if (
            filterValue !== "ALL" &&
            filterValue !== "SYSTEM_EVENTS_ONLY" &&
            normalizeAssetName(lasset) !== normalizeAssetName(filterValue)
        ) continue;

        if (!isSystemEvent && !stateMatcher(lstateVal)) continue;

        let escapedNote = cleanNote(lnote).replace(/"/g, "&quot;").replace(/'/g, "\\'");

        if (!isMobile) {
            let tr = document.createElement('tr');
            if (isSystemEvent) tr.style.backgroundColor = "#e3f2fd";
            function td(txt) { let e = document.createElement('td'); e.innerHTML = txt; return e; }
            tr.appendChild(td(ldate)); tr.appendChild(td(ltime)); tr.appendChild(td(lasset));
            tr.appendChild(td(levent));
            let stateDisplay = lstateVal == "1" ? "<span style='color:#256029;font-weight:bold;'>RUNNING</span>" : "<span style='color:#b71c1c;font-weight:bold;'>STOPPED</span>";
            if (isSystemEvent) stateDisplay = lstateVal == "1" ? "<span style='color:#256029;font-weight:bold;'>UP</span>" : "<span style='color:#b71c1c;font-weight:bold;'>DOWN</span>";
            tr.appendChild(td(stateDisplay));
            tr.appendChild(td(Number(lavail).toFixed(2)));
            tr.appendChild(td(minToHHMMSS(lrun))); tr.appendChild(td(minToHHMMSS(lstop)));
            tr.appendChild(td(minToHHMMSS(lmtbf))); tr.appendChild(td(minToHHMMSS(lmttr)));
            tr.appendChild(td(String(stopsInt)));
            tr.appendChild(td(isSystemEvent ? "" : (levent.toUpperCase() === "STOP" ? durationStrToHHMMSS(runDurStr) : "")));
            tr.appendChild(td(isSystemEvent ? "" : (levent.toUpperCase() === "START" ? durationStrToHHMMSS(stopDurStr) : "")));
            let tdNote = document.createElement('td');
            tdNote.innerHTML = `<span class='note'>${cleanNote(lnote)}</span> <button class='notebtn' onclick='showNoteModal("${ldate}","${ltime}","${lasset}","${escapedNote}")'>Edit</button>`;
            tr.appendChild(tdNote);
            tbody.appendChild(tr);
        } else {
            let card = document.createElement('div');
            card.className = 'eventCard';
            if (isSystemEvent) card.style.backgroundColor = "#e3f2fd";
            let stateDisplayMob = lstateVal == "1" ? "<span style='color:#256029;'>RUNNING</span>" : "<span style='color:#b71c1c;'>STOPPED</span>";
            if (isSystemEvent) stateDisplayMob = lstateVal == "1" ? "<span style='color:#256029;'>UP</span>" : "<span style='color:#b71c1c;'>DOWN</span>";
            card.innerHTML =
                `<div><b>Date:</b> ${ldate}</div><div><b>Time:</b> ${ltime}</div><div><b>Asset:</b> ${lasset}</div><div><b>Event:</b> ${levent}</div>` +
                `<div><b>State:</b> ${stateDisplayMob}</div>` +
                `<div><b>Avail(%):</b> ${Number(lavail).toFixed(2)}</div><div><b>Runtime:</b> ${minToHHMMSS(lrun)}</div><div><b>Downtime:</b> ${minToHHMMSS(lstop)}</div>` +
                `<div><b>MTBF:</b> ${minToHHMMSS(lmtbf)}</div><div><b>MTTR:</b> ${minToHHMMSS(lmttr)}</div><div><b>Stops:</b> ${stopsInt}</div>` +
                (isSystemEvent ? "" : `<div><b>Run Dur:</b> ${levent.toUpperCase() === "STOP" ? durationStrToHHMMSS(runDurStr) : ""}</div><div><b>Stop Dur:</b> ${levent.toUpperCase() === "START" ? durationStrToHHMMSS(stopDurStr) : ""}</div>`) +
                `<div><b>Note:</b> <span class='note'>${cleanNote(lnote)}</span> <button class='notebtn' onclick='showNoteModal("${ldate}","${ltime}","${lasset}","${escapedNote}")'>Edit</button></div>`;
            mobileDiv.appendChild(card);
        }
    }
    const ec = document.getElementById('eventCount'); if (ec) ec.innerHTML = "<b>Events:</b> " + (isMobile ? mobileDiv.children.length : tbody.children.length);
    const et = document.getElementById('eventTable'); if (et) et.style.display = isMobile ? 'none' : '';
    if (mobileDiv) mobileDiv.style.display = isMobile ? '' : 'none';
    if (!scrollInhibit) { if (isMobile) { if (mobileDiv) mobileDiv.scrollTop = 0; } else { window.scrollTo({ top: 0, behavior: 'auto' }); } }
    scrollInhibit = false;
}

function toggleScrollInhibit(btn) {
  scrollInhibit = !scrollInhibit;
  if(btn) btn.innerText = scrollInhibit ? "Enable Auto-Scroll" : "Inhibit Auto-Scroll"; 
}

if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initializeEventPage); } 
else { initializeEventPage(); }
)rawliteral");
  server.sendContent("</script>");
  server.sendContent("</head><body>");
  server.sendContent("<header><div style='font-size:1.6em;font-weight:700;'>Event Log</div></header>");
  String navHtml = "<nav class='nav'>";
  navHtml += "<a href='/' class='nav-btn'>Dashboard</a>";
  navHtml += "<a href='/config' class='nav-btn'>Setup</a>";
  navHtml += "<a href='/export_log' class='nav-btn'>Export CSV</a>";
  navHtml += "</nav>";
  server.sendContent(navHtml);

  String mainCardOpen = "<div class='main card'>";
  server.sendContent(mainCardOpen);

  String filterRowHtml = "<div class='filterrow'><label for='channelFilter'>Filter by Channel:</label> <select id='channelFilter'><option value='ALL'>All Assets</option></select>";
  filterRowHtml += "<label for='stateFilter'>Event State:</label> <select id='stateFilter'><option value='ALL'>All</option><option value='RUNNING'>Running</option><option value='STOPPED'>Stopped</option></select>";
  filterRowHtml += "<span id='eventCount' style='margin-left:1em;'></span>";
  filterRowHtml += "<button class='scrollToggle' id='scrollBtn' type='button' onclick='toggleScrollInhibit(this)'>Inhibit Auto-Scroll</button></div>";
  server.sendContent(filterRowHtml);
  
  String tableHtml = "<div style='overflow-x:auto;'><table id='eventTable'><thead><tr>";
  tableHtml += "<th>Date</th><th>Time</th><th>Asset</th><th>Event</th><th>State</th><th>Avail(%)</th><th>Runtime</th><th>Downtime</th><th>MTBF</th><th>MTTR</th><th>Stops</th><th>Run Duration</th><th>Stop Duration</th><th>Note</th>";
  tableHtml += "</tr></thead><tbody id='tbody'></tbody></table>";
  tableHtml += "<div id='mobileEvents'></div></div>";
  server.sendContent(tableHtml);
  
  String modalHtml = R"rawliteral(
<div id="noteEditModal" class="modal-overlay">
  <div class="modal-content">
    <h3 class="modal-title">Edit Event Note</h3>
    <form id="modalNoteForm" onsubmit="return submitModalNote(event)">
      <input type="hidden" id="modalNoteDate" name="date">
      <input type="hidden" id="modalNoteTime" name="time">
      <input type="hidden" id="modalNoteAsset" name="asset">
      <label for="modalNoteReason">Reason:</label>
      <select id="modalNoteReason" name="reason"><option value=""></option></select>
      <label for="modalNoteText">Note:</label>
      <input type="text" id="modalNoteText" name="note" maxlength="64" placeholder="Add/Edit note">
      <div class="modal-actions">
        <button type="submit" class="btn-save">Save</button>
        <button type="button" class="btn-cancel" onclick="hideNoteModal()">Cancel</button>
      </div>
    </form>
  </div>
</div>
)rawliteral";
  server.sendContent(modalHtml);

  server.sendContent("</div></body></html>");
  server.sendContent("");
}


String htmlConfig() {
  String html = "<!DOCTYPE html><html lang='en'><head><title>Setup</title><meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<link href='https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap' rel='stylesheet'>";
  html += "<style>";
  html += "body{font-family:Roboto,sans-serif;background:#f3f7fa;margin:0;}";
  html += "header{background:#1976d2;color:#fff;padding:1.2rem 0;text-align:center;box-shadow:0 2px 10px #0001; font-size:1.6em; font-weight:700;}";
  html += ".nav{display:flex;justify-content:center;gap:1rem;margin:1rem 0;flex-wrap:wrap;align-items:center;}";
  html += ".nav button, .nav a {text-decoration:none;background:#fff;color:#1976d2;border:none;border-radius:6px;padding:0.7em 1.1em;font-size:1.1em;font-weight:700;box-shadow:0 2px 8px #0001;cursor:pointer;margin:0.2em 0.4em;}";
  html += ".nav button:hover, .nav a:hover {background:#e3f0fc;}";
  html += ".nav .right{margin-left:auto;}";
  html += ".main{max-width:700px;margin:1rem auto;padding:1rem;}";
  html += ".card{background:#fff;border-radius:10px;box-shadow:0 2px 16px #0002;margin-bottom:1.3rem;padding:1.3rem;}";
  html += "label{font-weight:500;margin-top:1em;display:block;}input[type=text],input[type=number],select{width:100%;padding:0.6em;margin-top:0.2em;margin-bottom:1em;border:1px solid #ccc;border-radius:5px;font-size:1em;}";
  html += "input[type=submit].form-button,button.form-button{width:100%;margin-top:1em;padding:0.8em 1.5em;font-size:1.15em;border-radius:8px;border:none;background:#1976d2;color:#fff;font-weight:700;cursor:pointer;}";
  html += "input[type=submit].form-button:hover,button.form-button:hover{background:#1253a2;}";
  html += ".notice{background:#e6fbe7;color:#256029;font-weight:bold;padding:0.6em 1em;border-radius:7px;margin-bottom:1em;text-align:center;}";
  html += "button.wifi-reconfig{background:#f44336 !important; color:#fff !important;}";
  html += ".config-tile { margin-bottom: 1rem; border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden; }";
  html += ".config-tile-header { background-color: #e9eff4; color: #1976d2; padding: 0.8em 1em; width: 100%; border: none; text-align: left; font-size: 1.1em; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: space-between; }";
  html += ".config-tile-header:hover { background-color: #dce7f0; }";
  html += ".config-tile-header .toggle-icon { font-size: 1.2em; transition: transform 0.2s; }";
  html += ".config-tile-header.active .toggle-icon { transform: rotate(45deg); }";
  html += ".config-tile-content { padding: 0 1.3rem 1.3rem 1.3rem; display: none; background-color: #fff; border-top: 1px solid #e0e0e0;}";
  html += ".config-tile-content.open { display: block; }";
  html += ".config-tile-content fieldset { border:1px solid #e0e0e0;padding:1em;border-radius:7px;margin-top:1em;margin-bottom:0.5em; }";
  html += ".config-tile-content fieldset legend { font-weight:700;color:#2196f3;font-size:1.05em;padding:0 0.5em; }";
  html += "@media(max-width:700px){.main{padding:0.5rem;} .card{padding:0.7rem;} input[type=submit].form-button,button.form-button{font-size:1em;} .config-tile-content{padding:0 0.7rem 0.7rem 0.7rem;}}";
  html += "</style>";
  html += "<script>";
  html += "function clearLogDblConfirm(e){ if(!confirm('Are you sure you want to CLEAR ALL LOG DATA?')){e.preventDefault();return false;} if(!confirm('Double check: This cannot be undone! Are you REALLY sure?')){e.preventDefault();return false;}return true;}";
  html += "function showSavedMsg(){ const notice = document.getElementById('saveNotice'); if(notice) notice.style.display='block'; }";
  html += "function confirmWiFiReconfig(e){ if(!confirm('Are you sure you want to enter WiFi setup mode? The device will disconnect from the current network and restart as an Access Point.')){e.preventDefault();return false;}return true;}";
  html += "function setupConfigTiles() {";
  html += "  document.querySelectorAll('.config-tile-header').forEach(header => {";
  html += "    header.addEventListener('click', () => {";
  html += "      const content = header.nextElementSibling;";
  html += "      const icon = header.querySelector('.toggle-icon');";
  html += "      header.classList.toggle('active');";
  html += "      if (content.classList.contains('open')) {";
  html += "        content.classList.remove('open');";
  html += "        if(icon) icon.textContent = '+';";
  html += "      } else {";
  html += "        content.classList.add('open');";
  html += "        if(icon) icon.textContent = '-';";
  html += "      }";
  html += "    });";
  html += "  });";
  html += "  const firstTileHeader = document.querySelector('.config-tile:first-child .config-tile-header');";
  html += "  if (firstTileHeader && !firstTileHeader.classList.contains('active')) {";
  html += "    firstTileHeader.click();";
  html += "  }";
  html += "}";
  html += "document.addEventListener('DOMContentLoaded', setupConfigTiles);";
  html += "</script>";
  html += "</head><body>";
  html += "<header>Setup</header>";
  html += "<nav class='nav'>";
  html += "<a href='/' class='nav-btn'>Dashboard</a>";
  html += "<a href='/events' class='nav-btn'>Event Log</a>";
  html += "<a href='/export_log' class='nav-btn'>Export CSV</a>";
  html += "<form action='/clear_log' method='POST' style='display:inline;margin:0;' onsubmit='return clearLogDblConfirm(event);'><button type='submit' style='background:#f44336;color:#fff;' class='nav-btn'>Clear Log</button></form>";
  html += "</nav>";
  html += "<div class='main'><div class='card'>";

  // --- PATCH: Asset Rename Warning ---
  html += "<div id='assetRenameWarning' style='display:none;color:#b71c1c;background:#fff3e0;padding:0.7em;margin-bottom:1em;border:1px solid #fbc02d;border-radius:7px;'></div>";
  // --- END PATCH ---

  html += "<form method='POST' action='/save_config' id='setupform' onsubmit='setTimeout(showSavedMsg, 500);'>";
  html += "<div id='saveNotice' class='notice' style='display:none;'>Settings saved! Device is rebooting...</div>";

  html += "<div class='config-tile'>";
  html += "  <button type='button' class='config-tile-header'>Asset Setup <span class='toggle-icon'>+</span></button>";
  html += "  <div class='config-tile-content'>";
  html += "    <label>Asset count (max " + String(MAX_ASSETS) + "): <input type='number' name='assetCount' min='1' max='" + String(MAX_ASSETS) + "' value='" + String(config.assetCount) + "' required></label>";
  html += "    <p style='font-size:0.9em; color:#555; margin-top:-0.5em; margin-bottom:1em;'>To change the number of assets, update this count and click 'Save All Settings & Reboot'. The page will refresh with more/less asset fields.</p>";
  for (uint8_t i = 0; i < config.assetCount; ++i) {
    if (i >= MAX_ASSETS) break;
    html += "    <fieldset><legend>Asset #" + String(i+1) + "</legend>";
    html += "      <label>Name: <input type='text' name='name" + String(i) + "' value='" + String(config.assets[i].name) + "' maxlength='31' required></label>";
    html += "      <label>GPIO Pin: <input type='number' name='pin" + String(i) + "' value='" + String(config.assets[i].pin) + "' min='0' max='39' required></label>";
    html += "    </fieldset>";
  }
  html += "  </div>";
  html += "</div>";

  html += "<div class='config-tile'>";
  html += "  <button type='button' class='config-tile-header'>Operational Settings <span class='toggle-icon'>+</span></button>";
  html += "  <div class='config-tile-content'>";
  html += "    <label>Max events per asset (log size): <input type='number' name='maxEvents' min='100' max='5000' value='" + String(config.maxEvents) + "' required></label>";
  html += "    <label>Timezone offset from UTC (hours): <input type='number' name='tzOffset' min='-12' max='14' step='0.5' value='" + String(config.tzOffset / 3600.0, 1) + "' required></label>";
  html += "    <label>Highlight stops longer than (min): <input type='number' name='longStopThreshold' min='1' max='1440' value='" + String(config.longStopThresholdSec/60) + "' required></label>";
  html += "    <label>Monitoring Mode:</label>";
  html += "    <select name='monitoringMode'>";
  html += "      <option value='" + String(MONITORING_MODE_PARALLEL) + "'";
  if (config.monitoringMode == MONITORING_MODE_PARALLEL) html += " selected";
  html += ">Parallel (Assets Independent)</option>";
  html += "      <option value='" + String(MONITORING_MODE_SERIAL) + "'";
  if (config.monitoringMode == MONITORING_MODE_SERIAL) html += " selected";
  html += ">Serial (System Stops if Any Asset Stops)</option>";
  html += "    </select>";
  html += "  </div>";
  html += "</div>";

  html += "<div class='config-tile'>";
  html += "  <button type='button' class='config-tile-header'>Downtime Quick Reasons <span class='toggle-icon'>+</span></button>";
  html += "  <div class='config-tile-content'>";
  for (int i = 0; i < 5; ++i) {
    html += "    <label>Reason " + String(i+1) + ": <input type='text' name='reason" + String(i) + "' value='" + String(config.downtimeReasons[i]) + "' maxlength='31'></label>";
  }
  html += "  </div>";
  html += "</div>";

  html += "<input type='submit' value='Save All Settings & Reboot' class='form-button' style='width:100%; margin-top:1.5rem;'>";
  html += "</form>";

  html += "<div class='config-tile' style='margin-top:1.5rem;'>";
  html += "  <button type='button' class='config-tile-header'>Network Configuration <span class='toggle-icon'>+</span></button>";
  html += "  <div class='config-tile-content'>";
  html += "    <p style='margin-top:0; margin-bottom:0.5em;'><strong>Current WiFi Status:</strong> ";
  if (WiFi.status() == WL_CONNECTED) {
    html += "Connected to " + WiFi.SSID();
    html += " (IP: " + WiFi.localIP().toString() + ")";
  } else if (WiFi.getMode() == WIFI_AP) {
    html += "Currently in Access Point Mode ('AssetMonitor_Config')";
  } else {
    html += "Not Connected / Status Unknown";
  }
  html += "</p>";
  html += "    <p style='margin-top:0.5em; margin-bottom:1em;'>If you need to connect to a different WiFi network or re-enter credentials, use the button below. The device will restart in WiFi Setup Mode.</p>";
  html += "    <form method='POST' action='/reconfigure_wifi' onsubmit='return confirmWiFiReconfig(event);' style='margin-top:0.5em;'>";
  html += "      <button type='submit' class='form-button wifi-reconfig'>Enter WiFi Setup Mode</button>";
  html += "    </form>";
  html += "  </div>";
  html += "</div>";

  html += "</div></div>";

  // --- PATCH: Asset rename warning JS ---
  html += "<script>";
  html += "function normalizeAssetName(name){return(name||'').toLowerCase().replace(/\\s+/g,'');}";
  html += "function checkAssetRenameWarning(){";
  html += "fetch('/api/events').then(r=>r.json()).then(events=>{";
  html += "const assetNamesInLog=new Set(events.map(row=>row[2]&&normalizeAssetName(row[2])));";
  html += "const currentAssetInputs=Array.from(document.querySelectorAll('input[name^=\"name\"]'));";
  html += "let unmatchedOldNames=[];";
  html += "currentAssetInputs.forEach(input=>{";
  html += "if(input.value){let norm=normalizeAssetName(input.value);if(assetNamesInLog.size>0&&!assetNamesInLog.has(norm)){unmatchedOldNames.push(input.value);}}});";
  html += "const warningDiv=document.getElementById('assetRenameWarning');";
  html += "if(warningDiv){";
  html += "if(unmatchedOldNames.length){";
  html += "warningDiv.style.display='';";
  html += "warningDiv.innerHTML='<b>Warning:</b> Historical event log entries may not match the current asset names. Old entries may not appear in the Event Log or Analytics. Consider clearing the log if you have renamed assets.';";
  html += "}else{warningDiv.style.display='none';}";
  html += "}});}";
  html += "window.addEventListener('DOMContentLoaded',()=>{checkAssetRenameWarning();document.querySelectorAll('input[name^=\"name\"]').forEach(input=>{input.addEventListener('change',checkAssetRenameWarning);});});";
  html += "</script>";
  // --- END PATCH ---

  html += "</body></html>";
  return html;
}

String htmlAssetDetail(uint8_t idx) { // From your V21
  if (idx >= config.assetCount || idx >= MAX_ASSETS) return "Invalid Asset Index";
  String assetNameStr = String(config.assets[idx].name);
  String html = "<!DOCTYPE html><html><head><title>Asset Detail: " + assetNameStr + "</title>";
  html += "<meta name='viewport' content='width=device-width,initial-scale=1'><style>body{font-family:Roboto,Arial,sans-serif;margin:2em;background:#f3f7fa;} .card{background:#fff;padding:1.5em;border-radius:8px;box-shadow:0 2px 8px #0001;} h1{color:#1976d2;}</style></head><body><div class='card'>";
  html += "<h1>Asset Detail: " + assetNameStr + "</h1><p><strong>GPIO Pin:</strong> " + String(config.assets[idx].pin) + "</p>";
  html += "<p><a href='/'>Back to Dashboard</a></p><p><a href='/analytics?asset=" + urlEncode(assetNameStr) + "'>View Analytics</a></p></div></body></html>";
  return html;
}

// V21.ino (Continued - Chunk 9: Handler Functions)

void handleWiFiReconfigurePost() { // From your V21
  prefs.begin("assetmon", false); prefs.remove("ssid"); prefs.remove("pass"); prefs.end();
  Serial.println("WiFi credentials cleared. Restarting in AP mode.");
  String message = "<!DOCTYPE html><html><head><title>WiFi Reconfiguration</title><style>body{font-family:Arial,sans-serif;margin:20px;padding:15px;border:1px solid #ddd;border-radius:5px;text-align:center;} h2{color:green;}</style></head><body><h2>WiFi Credentials Cleared</h2><p>Device will now restart in Access Point mode ('AssetMonitor_Config'). Connect to this AP to set up new WiFi.</p><p>This page will attempt to redirect in 5 seconds, or you can manually go to the device's new IP (usually 192.168.4.1) once connected to the AP.</p><meta http-equiv='refresh' content='7;url=http://192.168.4.1/' /></body></html>"; // Added more info to message
  server.sendHeader("Connection", "close"); server.send(200, "text/html", message);
  delay(1500); // Slightly longer delay
  ESP.restart();
}

void handleConfigPost() { // Patched version
  bool rebootNeeded = false;

  if (server.hasArg("assetCount")) {
    uint8_t oldAssetCount = config.assetCount;
    config.assetCount = constrain(server.arg("assetCount").toInt(), 1, MAX_ASSETS);
    if (config.assetCount != oldAssetCount) { // Count changed
        rebootNeeded = true;
    }
    // Initialize new assets if count increased, or just update existing
    for (uint8_t i = 0; i < MAX_ASSETS; ++i) { // Iterate up to MAX_ASSETS to clear old if count reduced
      if (i < config.assetCount) { // For assets within the new count
        if (server.hasArg("name"+String(i))) {
             String newName = server.arg("name"+String(i));
             if (strcmp(config.assets[i].name, newName.c_str()) != 0) rebootNeeded = true; // Name change might affect things
             strncpy(config.assets[i].name, newName.c_str(), 31); config.assets[i].name[31] = '\0';
        }
        if (server.hasArg("pin"+String(i))) {
            uint8_t newPin = server.arg("pin"+String(i)).toInt();
            if (config.assets[i].pin != newPin) rebootNeeded = true; // Pin change definitely requires reboot
            config.assets[i].pin = newPin;
        }
      } else { // For assets beyond the new count, clear them
          if (strlen(config.assets[i].name) > 0) rebootNeeded = true; // If there was a name, it's being cleared
          config.assets[i].name[0] = '\0';
          config.assets[i].pin = 0; // Or some other invalid pin marker
      }
    }
  } else {
     server.send(400, "text/plain", "Bad Request: assetCount missing."); return;
  }

  if (server.hasArg("maxEvents")) {
      uint16_t newMaxEvents = constrain(server.arg("maxEvents").toInt(), 100, 5000);
      if (newMaxEvents != config.maxEvents) rebootNeeded = true; // Log size change might be considered major
      config.maxEvents = newMaxEvents;
  }
  if (server.hasArg("tzOffset")) {
      int newTzOffset = static_cast<int>(server.arg("tzOffset").toFloat() * 3600);
      if (newTzOffset != config.tzOffset) {
          rebootNeeded = true; // Timezone change requires reboot for full effect
          config.tzOffset = newTzOffset;
      }
  }
  for (int i=0; i<5; ++i) {
      if(server.hasArg("reason"+String(i))) {
          strncpy(config.downtimeReasons[i], server.arg("reason"+String(i)).c_str(), 31);
          config.downtimeReasons[i][31] = '\0';
      }
  }
  if (server.hasArg("longStopThreshold")) {
      config.longStopThresholdSec = constrain(server.arg("longStopThreshold").toInt() * 60, 60, 1440 * 60);
  }

  if (server.hasArg("monitoringMode")) {
    int newMode = server.arg("monitoringMode").toInt();
    if (newMode != config.monitoringMode &&
        (newMode == MONITORING_MODE_PARALLEL || newMode == MONITORING_MODE_SERIAL)) {
      config.monitoringMode = newMode;
      g_isSystemSerialDown = false;
      g_serialSystemTriggerAssetName[0] = '\0';
      g_systemTotalRunningTimeSecs = 0;
      g_systemTotalStoppedTimeSecs = 0;
      g_systemStopCount = 0;
      g_systemStateInitialized = false;
      rebootNeeded = true;
    }
  }

  saveConfig();
  // Your original code always rebooted on /save_config via redirect and ESP.restart()
  // The rebootNeeded logic can make this conditional if desired in the future.
  // For now, matching original behavior:
  server.sendHeader("Location", "/config#saveNotice"); // Redirect to show the notice
  server.send(303);
  delay(1000);
  ESP.restart();
}

void handleClearLog() { // Patched version
  SPIFFS.remove(LOG_FILENAME);
  Serial.println("Log cleared.");

  time_t now = time(nullptr);
  for (uint8_t i = 0; i < config.assetCount; ++i) {
    if (i < MAX_ASSETS) {
      assetStates[i].lastChangeTime = now;
      assetStates[i].sessionStart = now;
      assetStates[i].runningTime = 0; assetStates[i].stoppedTime = 0;
      assetStates[i].runCount = 0; assetStates[i].stopCount = 0;
      assetStates[i].lastEventTime = now;
      assetStates[i].lastRunDuration = 0; assetStates[i].lastStopDuration = 0;
      if (config.assets[i].pin > 0 && config.assets[i].pin < 40) {
          assetStates[i].lastState = digitalRead(config.assets[i].pin);
      } else {
          assetStates[i].lastState = true;
      }
    }
  }

  if (config.monitoringMode == MONITORING_MODE_SERIAL) {
    g_systemTotalRunningTimeSecs = 0;
    g_systemTotalStoppedTimeSecs = 0;
    g_systemStopCount = 0;
    g_systemLastStateChangeTime = now;
    g_systemStateInitialized = false; // Will force re-evaluation

    bool anyAssetCurrentlyStopped = false;
    g_serialSystemTriggerAssetName[0] = '\0';
    for (uint8_t k = 0; k < config.assetCount; ++k) {
      if (k < MAX_ASSETS) {
          bool assetEffectivelyStopped = assetStates[k].lastState;
          if (config.assets[k].pin == 0 || config.assets[k].pin >= 40) assetEffectivelyStopped = true;
          if (assetEffectivelyStopped) {
            anyAssetCurrentlyStopped = true;
            if (g_serialSystemTriggerAssetName[0] == '\0') {
                strncpy(g_serialSystemTriggerAssetName, config.assets[k].name, 31);
                g_serialSystemTriggerAssetName[31] = '\0';
            }
          }
      }
    }
    g_isSystemSerialDown = anyAssetCurrentlyStopped;
    g_systemStateInitialized = true;
    Serial.printf("Log cleared. Serial Mode: System state re-evaluated. Down: %s. Trigger: %s\n",
                  g_isSystemSerialDown ? "Yes" : "No",
                  g_isSystemSerialDown ? g_serialSystemTriggerAssetName : "N/A");
    if (g_isSystemSerialDown) {
        logSystemEvent(false, now, g_serialSystemTriggerAssetName);
    } else {
        logSystemEvent(true, now, "System State After Log Clear - All Assets Up");
    }
  }
  server.sendHeader("Location", "/config"); // Or wherever you want to redirect
  server.send(303);
}

void handleExportLog() { // From your V21
  File f = SPIFFS.open(LOG_FILENAME, FILE_READ);
  if (!f || f.size() == 0) { server.send(404, "text/plain", "Log empty or not found."); if(f)f.close(); return; }
  time_t now_val = time(nullptr); struct tm *t_val = localtime(&now_val); char fn[64]; strftime(fn, sizeof(fn), "AssetLog-%Y%m%d-%H%M.csv", t_val);
  server.sendHeader("Content-Type", "text/csv"); server.sendHeader("Content-Disposition", String("attachment; filename=\"")+fn+"\"");
  server.setContentLength(f.size() + strlen("Date,Time,Asset,Event,State,Avail(%),Runtime(min),Downtime(min),MTBF(min),MTTR(min),Stops,RunDur,StopDur,Note\n")); // Approximate for progress bars
  server.send(200, "text/csv", "");
  server.sendContent("Date,Time,Asset,Event,State,Avail(%),Runtime(min),Downtime(min),MTBF(min),MTTR(min),Stops,RunDur,StopDur,Note\n");
  char buf[1025]; size_t br;
  while(f.available()){
    br=f.readBytes(buf,1024);
    if(br>0){ server.sendContent(buf, br); } // Send exact bytes read
  }
  f.close();
  // server.sendContent(""); // Final empty chunk to signify end if not using chunked encoding explicitly
  Serial.println("Log exported.");
}

void handleApiSummary() { // Patched version
  String json = "{";
  time_t now = time(nullptr);

  json += "\"monitoringMode\":" + String(config.monitoringMode) + ","; // Add current mode

  if (config.monitoringMode == MONITORING_MODE_SERIAL) {
    json += "\"systemStats\":{";
    json += "\"isDown\":" + String(g_isSystemSerialDown ? "true" : "false") + ",";
    json += "\"triggerAsset\":\"" + String(g_serialSystemTriggerAssetName) + "\",";

    unsigned long currentSystemRunTime = g_systemTotalRunningTimeSecs;
    unsigned long currentSystemStopTime = g_systemTotalStoppedTimeSecs;
    if (g_systemStateInitialized && g_systemLastStateChangeTime > 0) {
        unsigned long durationSinceLastChange = now - g_systemLastStateChangeTime;
        if (!g_isSystemSerialDown) { currentSystemRunTime += durationSinceLastChange; }
        else { currentSystemStopTime += durationSinceLastChange; }
    }

    float systemAvailability = (currentSystemRunTime + currentSystemStopTime) > 0
                               ? (100.0f * currentSystemRunTime / (currentSystemRunTime + currentSystemStopTime))
                               : (g_isSystemSerialDown ? 0.0f : 100.0f);
    json += "\"availability\":" + String(systemAvailability, 2) + ",";
    json += "\"totalRunningTimeSecs\":" + String(currentSystemRunTime) + ","; // For JS to convert to minutes/format
    json += "\"totalStoppedTimeSecs\":" + String(currentSystemStopTime) + ",";
    json += "\"stopCount\":" + String(g_systemStopCount) + ",";

    float systemMtbf_min = (g_systemStopCount > 0) ? ((float)currentSystemRunTime / 60.0f / g_systemStopCount) : (currentSystemRunTime > 0 ? (float)currentSystemRunTime / 60.0f : 0.0f) ;
    float systemMttr_min = (g_systemStopCount > 0) ? ((float)currentSystemStopTime / 60.0f / g_systemStopCount) : 0.0f;
    json += "\"mtbf_min\":" + String(systemMtbf_min, 2) + ","; // Key for JS dashboard
    json += "\"mttr_min\":" + String(systemMttr_min, 2);     // Key for JS dashboard
    json += "},";
  }

  json += "\"assets\":[";
  for (uint8_t i = 0; i < config.assetCount; ++i) {
    if (i >= MAX_ASSETS) continue;
    if (i > 0) json += ",";
    AssetState& as = assetStates[i];
    bool pin_s = true; // Assume stopped if pin invalid
    if (config.assets[i].pin > 0 && config.assets[i].pin < 40) {
        pin_s = digitalRead(config.assets[i].pin);
    }


    unsigned long runT_current = as.runningTime;
    unsigned long stopT_current = as.stoppedTime;
    if (as.lastChangeTime > 0) { // Add time since last event to current state's bucket
        unsigned long timeSinceLastChange = now - as.lastChangeTime;
        if (as.lastState == false) { // Was RUNNING (pin LOW)
            runT_current += timeSinceLastChange;
        } else { // Was STOPPED (pin HIGH)
            stopT_current += timeSinceLastChange;
        }
    }

    float avail = (runT_current + stopT_current) > 0 ? (100.0 * runT_current / (runT_current + stopT_current)) : (pin_s == false ? 100.0 : 0.0);
    float rt_m = runT_current / 60.0;
    float st_m = stopT_current / 60.0;
    float mtbf_calc = (as.stopCount > 0) ? rt_m / as.stopCount : (runT_current > 0 ? rt_m : 0.0); // MTBF in minutes
    float mttr_calc = (as.stopCount > 0) ? st_m / as.stopCount : 0.0;    // MTTR in minutes

    json += "{";
    json += "\"name\":\"" + String(config.assets[i].name) + "\",";
    json += "\"pin\":" + String(config.assets[i].pin) + ",";
    json += "\"state\":" + String(pin_s ? 0 : 1) + ",";
    json += "\"availability\":" + String(avail, 2) + ",";
    json += "\"total_runtime\":" + String(rt_m, 2) + ","; // Your dashboard JS expects this key
    json += "\"total_downtime\":" + String(st_m, 2) + ",";
    json += "\"mtbf\":" + String(mtbf_calc, 2) + ",";
    json += "\"mttr\":" + String(mttr_calc, 2) + ",";
    json += "\"stop_count\":" + String(as.stopCount);
    // Add last run/stop durations if your dashboard JS uses them
    json += ",\"lastRunDurationSecs\":" + String(as.lastRunDuration);
    json += ",\"lastStopDurationSecs\":" + String(as.lastStopDuration);
    json += "}";
  }
  json += "]}";
  server.send(200, "application/json", json);
}

// Replace your existing handleApiEvents with this one:
void handleApiEvents() {
  File f = SPIFFS.open(LOG_FILENAME, FILE_READ);
  String jsonOutput = "[";
  bool firstLine = true;

  if (f && f.size() > 0) {
    while (f.available()) {
      String line = f.readStringUntil('\n');
      line.trim();
      if (line.length() < 5) continue; // Skip empty or too short lines

      if (!firstLine) {
        jsonOutput += ",";
      }
      firstLine = false;

      jsonOutput += "[";
      int start = 0;
      int commaPos = 0;
      bool firstField = true;
      // Split the CSV line into fields and make each a JSON string
      while(start < line.length()) {
          commaPos = line.indexOf(',', start);
          if (commaPos == -1) { // Last field
              commaPos = line.length();
          }
          String field = line.substring(start, commaPos);
          // Escape quotes and backslashes within the field for JSON string validity
          String escapedField = "";
          for (unsigned int k=0; k < field.length(); k++) {
              char c = field.charAt(k);
              if (c == '"') escapedField += "\\\"";
              else if (c == '\\') escapedField += "\\\\";
              else escapedField += c;
          }

          if (!firstField) {
              jsonOutput += ",";
          }
          jsonOutput += "\"" + escapedField + "\"";
          firstField = false;
          start = commaPos + 1;
          if (start >= line.length() && commaPos == line.length()) break; // handles trailing empty field if line ends with comma
      }
      jsonOutput += "]";
    }
    f.close();
  }
  jsonOutput += "]";

  server.sendHeader("Cache-Control", "no-cache,no-store,must-revalidate");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "-1");
  server.send(200, "application/json", jsonOutput);
}

void handleApiConfig() { // From your V21
  String json="{"; json+="\"assetCount\":"+String(config.assetCount)+","; json+="\"maxEvents\":"+String(config.maxEvents)+","; json+="\"tzOffset\":"+String(config.tzOffset)+","; json+="\"assets\":[";
  for(uint8_t i=0;i<config.assetCount;++i){if(i>=MAX_ASSETS)continue;if(i>0)json+=",";json+="{";json+="\"name\":\""+String(config.assets[i].name)+"\",";json+="\"pin\":"+String(config.assets[i].pin)+"}";}
  json+="],\"downtimeReasons\":["; for(int i=0;i<5;++i){if(i>0)json+=",";json+="\""+String(config.downtimeReasons[i])+"\"";} json+="]";
  json+=",\"longStopThresholdSec\":"+String(config.longStopThresholdSec);
  json+=",\"monitoringMode\":"+String(config.monitoringMode); // Added monitoring mode
  json+="}"; server.send(200,"application/json",json);
}

void handleApiNote() { // From your V21
  if(server.method()==HTTP_POST&&server.hasArg("date")&&server.hasArg("time")&&server.hasArg("asset")){
    String d=server.arg("date"),t=server.arg("time"),a=server.arg("asset"),n=server.arg("note"),r=server.hasArg("reason")?server.arg("reason"):"";
    Serial.printf("API Note: D=%s,T=%s,A=%s,R=%s,N=%s\n",d.c_str(),t.c_str(),a.c_str(),r.c_str(),n.c_str());
    updateEventNote(d,t,a,n,r); server.sendHeader("Location","/events"); server.send(303); return;
  } server.send(400,"text/plain","Bad Request: Note params missing");
}

void updateEventNote(String date_str, String time_str, String assetName_str, String note_text_str, String reason_str) { // From your V21
  File f = SPIFFS.open(LOG_FILENAME, FILE_READ); if (!f) { Serial.println("updateEventNote: Fail read log."); return; }
  String tempLog = ""; bool updated = false;
  String combinedNote = "";
  // Ensure reason_str and note_text_str are properly handled if one is empty
  if (reason_str.length()>0 && reason_str != "Other") { // "Other" is just a selector, not part of the note
    combinedNote = reason_str;
    if (note_text_str.length()>0) {
        combinedNote += " - " + note_text_str;
    }
  } else {
    combinedNote = note_text_str;
  }
  combinedNote.replace(",", ";"); // Replace commas with semicolons to avoid breaking CSV
  combinedNote.replace("\n", " "); combinedNote.replace("\r", " ");

  String line;
  while (f.available()) {
    line = f.readStringUntil('\n');
    String trimmedLine = line; trimmedLine.trim();
    if (trimmedLine.length() < 5) { tempLog += line; if(f.available() || line.endsWith("\n")) tempLog+=""; else tempLog+="\n"; continue; }

    String parts[3]; int pIdx = 0; int lastC = -1;
    for(int k=0; k<3; ++k) {
        int nextC = trimmedLine.indexOf(',', lastC + 1);
        if (nextC == -1) { parts[pIdx++] = trimmedLine.substring(lastC + 1); break; }
        parts[pIdx++] = trimmedLine.substring(lastC + 1, nextC); lastC = nextC;
    }
    for(int k=pIdx; k<3; ++k) parts[k] = "";

    if (parts[0] == date_str && parts[1] == time_str && parts[2] == assetName_str) {
      int finalComma = -1; int commaCount = 0;
      for(int i=0; i<trimmedLine.length(); ++i){ if(trimmedLine.charAt(i)==','){commaCount++; if(commaCount==13){finalComma=i;break;}}}
      if (finalComma != -1) tempLog += trimmedLine.substring(0, finalComma + 1) + combinedNote + "\n";
      else tempLog += trimmedLine + "," + combinedNote + "\n"; // Should not happen if 13 commas is correct
      updated = true; Serial.println("Updated log line for: " + date_str + " " + time_str + " " + assetName_str);
    } else {
      tempLog += line;
      if (!line.endsWith("\n") && f.available()) tempLog += "\n";
    }
  }
  f.close();

  if (updated) {
    File f2 = SPIFFS.open(LOG_FILENAME, FILE_WRITE);
    if (!f2) { Serial.println("updateEventNote: Fail write log."); return; }
    f2.print(tempLog); f2.close(); Serial.println("Log rewritten with updated note.");
  } else Serial.println("Event for note update not found: " + date_str + " " + time_str + " " + assetName_str);
}

void handleNotFound() { server.send(404, "text/plain", "Not found"); } // From your V21
