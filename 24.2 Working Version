#include <WiFi.h>
#include <WebServer.h>
#include <SPIFFS.h>
#include <Preferences.h>
#include <time.h>
#include <ctype.h>

// Forward declarations
String htmlDashboard();
String htmlAnalytics();
String htmlAnalyticsCompare();
String htmlConfig();
void sendHtmlEventsPage();
String wifiConfigHTML();
String htmlAssetDetail(uint8_t idx);
void handleConfigPost();
void handleClearLog();
void handleExportLog();
void handleApiSummary();
void handleApiEvents();
void handleApiConfig();
void handleApiNote();
void handleNotFound();
void updateEventNote(String date, String time, String assetName, String note, String reason);
void logEvent(uint8_t assetIdx, bool machineIsRunning, time_t now, const char* customNote = nullptr, unsigned long runDuration = 0, unsigned long stopDuration = 0);
void logSystemEvent(bool systemIsStarting, time_t now, const char* triggerAssetNameOrReason); // Added
void handleWiFiReconfigurePost();
void setupTime();
String urlEncode(const String& str);
String urlDecode(const String& str);
// --- Shift Logic Forward Declarations ---
void initializeShiftState();
void archiveLogAndResetForShift(int endedShiftIndex, const char* endedShiftStartTimeStr);
void processShiftLogic();
// void loadConfig(); // Already declared
// void setupWiFiSmart(); // Already declared

// USER CONFIGURATION
#define MAX_ASSETS 10
#define LOG_FILENAME "/log.csv"
const char* DEFAULT_DOWNTIME_REASONS[5] = {
  "Maintenance", "Material Shortage", "Operator Break", "Equipment Failure", "Changeover"
};

// --- Added Monitoring Mode Defines ---
#define MONITORING_MODE_PARALLEL 0
#define MONITORING_MODE_SERIAL 1
// --- End Added Defines ---

// --- Shift Defines & Structs ---
#define MAX_CONFIGURABLE_SHIFTS 5 // Allow up to 5 shifts to be defined

struct ShiftInfo {
  char startTime[6]; // "HH:MM" format, e.g., "06:00"
};

struct AssetConfig { char name[32]; uint8_t pin; };

struct Config {
  uint8_t assetCount;
  uint16_t maxEvents;
  AssetConfig assets[MAX_ASSETS];
  char downtimeReasons[5][32];
  int tzOffset;
  int longStopThresholdSec;
  int monitoringMode; // <<< ADDED for monitoring mode

  // --- NEW SHIFT CONFIGURATION ---
  bool enableShiftArchiving;
  uint8_t numShifts;
  ShiftInfo shifts[MAX_CONFIGURABLE_SHIFTS];
  // --- END NEW SHIFT CONFIGURATION ---
} config;

struct AssetState {
  bool lastState; // true if pin is HIGH (STOPPED for INPUT_PULLUP), false if pin is LOW (RUNNING)
  time_t lastChangeTime;
  unsigned long runningTime;  // Cumulative for current session/since last log clear
  unsigned long stoppedTime;  // Cumulative for current session/since last log clear
  unsigned long sessionStart; // Timestamp of when current session stats started (e.g. boot or log clear)
  unsigned long lastEventTime; // Timestamp of the last logged event for this asset
  uint32_t runCount;      // Number of times asset has started
  uint32_t stopCount;     // Number of times asset has stopped
  unsigned long lastRunDuration;  // Duration of the most recent run period
  unsigned long lastStopDuration; // Duration of the most recent stop period
};

// Event struct (no changes from your original)
struct Event {
  time_t timestamp; char assetName[32]; char eventType[8]; int state;
  float availability; float runtime; float downtime; float mtbf; float mttr;
  unsigned int stops; char runDuration[8]; char stopDuration[8]; char note[64];
  Event() { /* constructor */
    timestamp = 0; assetName[0] = '\0'; eventType[0] = '\0'; state = 0;
    availability = 0; runtime = 0; downtime = 0; mtbf = 0; mttr = 0;
    stops = 0; runDuration[0] = '\0'; stopDuration[0] = '\0'; note[0] = '\0';
  }
};

// V21.ino (Continued - Chunk 2)

WebServer server(80);
Preferences prefs; // Global prefs object (note: load/saveConfig use local ones)
AssetState assetStates[MAX_ASSETS];
char wifi_ssid[33] = "";
char wifi_pass[65] = "";

// --- Global Variables for System State (Serial Mode) ---
bool g_isSystemSerialDown = false;          // True if the overall system (in serial mode) is considered down
char g_serialSystemTriggerAssetName[32] = ""; // Name of the asset that triggered the system downtime
time_t g_systemLastStateChangeTime = 0;     // Timestamp of the last system-wide state change
unsigned long g_systemTotalRunningTimeSecs = 0; // Cumulative system running time
unsigned long g_systemTotalStoppedTimeSecs = 0; // Cumulative system stopped time
uint32_t g_systemStopCount = 0;             // Number of system-wide stop events
bool g_systemStateInitialized = false;      // Flag to check if system state has been initialized
// --- End System State Globals ---

// --- Globals for Shift Logic ---
int g_currentShiftIndex = -1;
time_t g_currentShiftStartTimeEpoch = 0;
bool g_shiftFeatureInitialized = false;

String wifiConfigHTML() {
  String html = "<!DOCTYPE html><html><head><title>WiFi Setup</title>"
                "<meta charset='UTF-8'>"
                "<style>"
                "body { font-family: Arial; margin: 2em; background: #f6f8fa; }"
                "form { background: #fff; padding: 2em; border-radius: 8px; box-shadow: 0 0 8px #ccc; max-width: 400px; margin:auto;}"
                "h1 { color: #0366d6; }"
                "label { display:block; margin-top:1em; }"
                "input[type=text], input[type=password] { width:100%; padding:0.5em; box-sizing: border-box; }"
                "input[type=submit] { background: #0366d6; color: #fff; border: none; padding: 0.7em 1.5em; margin-top:1em; border-radius: 4px; cursor:pointer;}"
                "input[type=submit]:hover { background: #0356b6; }"
                ".note { color: #888; font-size: 0.95em; margin: 1em 0; }"
                "</style>"
                "</head><body>"
                "<form method='POST' action='/wifi_save_config'>"
                "<h1>WiFi Setup</h1>"
                "<label>SSID:</label>"
                "<input type='text' name='ssid' maxlength='32' required value='";
  html += wifi_ssid;
  html += "'>"
          "<label>Password:</label>"
          "<input type='password' name='password' maxlength='64' value='";
  html += wifi_pass;
  html += "'>"
          "<div class='note'>Enter your WiFi details above. Device will reboot after saving.</div>"
          "<input type='submit' value='Save & Reboot'>"
          "</form>"
          "</body></html>";
  return html;
}

void handleWifiConfigPost() {
  if (server.hasArg("ssid")) {
    String ssid_arg = server.arg("ssid");
    String pass_arg = server.arg("password");
    strncpy(wifi_ssid, ssid_arg.c_str(), 32);
    wifi_ssid[32] = '\0';
    strncpy(wifi_pass, pass_arg.c_str(), 64);
    wifi_pass[64] = '\0';
    
    // Use the global prefs object for saving WiFi credentials
    prefs.begin("assetmon", false); // Ensure it's open for write
    prefs.putString("ssid", wifi_ssid);
    prefs.putString("pass", wifi_pass);
    prefs.end();

    server.send(200, "text/html", "<h2>Saved! Rebooting...</h2><meta http-equiv='refresh' content='3;url=/' />");
    delay(1000);
    ESP.restart();
  } else {
    server.send(400, "text/plain", "Missing WiFi credentials");
  }
}

void startConfigPortal() {
  WiFi.disconnect(true); // Ensure disconnection from any previous network
  WiFi.mode(WIFI_AP);
  WiFi.softAP("AssetMonitor_Config", "setpassword"); // Consider a more unique default password or make it configurable
  Serial.print("Config Portal Started. Connect to AP 'AssetMonitor_Config', IP: ");
  Serial.println(WiFi.softAPIP());
  server.on("/", HTTP_GET, [](){ server.send(200, "text/html", wifiConfigHTML()); });
  server.on("/wifi_save_config", HTTP_POST, handleWifiConfigPost);
  // Add a catch-all for other paths in AP mode to redirect to config
  server.onNotFound([](){ server.send(200, "text/html", wifiConfigHTML()); }); 
  server.begin();
  while (true) { server.handleClient(); delay(10); } // Loop indefinitely serving the config page
}

void setupWiFiSmart() {
  // Use the global prefs object for reading WiFi credentials
  if (!prefs.isKey("ssid")) { // Check if prefs was successfully begun before using isKey
     prefs.begin("assetmon", true); // Open read-only if not already begun
  }
  String ssid_from_prefs = prefs.getString("ssid", "");
  String pass_from_prefs = prefs.getString("pass", "");
  // prefs.end(); // Keep prefs open if it's global and used elsewhere, or manage its lifecycle carefully.
  // For this function, if it was opened here, it can be closed. If global, it depends.
  // Given your global `prefs`, it's likely intended to be open. Let's assume it's managed globally.

  if (ssid_from_prefs.length() == 0) {
    Serial.println("SSID not found in Preferences. Starting WiFi Configuration Portal.");
    startConfigPortal(); // This function will loop indefinitely until configured and rebooted
    return;
  }
  strncpy(wifi_ssid, ssid_from_prefs.c_str(), 32); wifi_ssid[32] = '\0';
  strncpy(wifi_pass, pass_from_prefs.c_str(), 64); wifi_pass[64] = '\0';

  WiFi.mode(WIFI_STA);
  WiFi.begin(wifi_ssid, wifi_pass);
  Serial.printf("Attempting to connect to WiFi SSID: %s", wifi_ssid);
  unsigned long connectStartTime = millis();
  while (WiFi.status() != WL_CONNECTED && (millis() - connectStartTime < 20000)) { // 20-second timeout
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("Successfully connected to WiFi!");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nFailed to connect to WiFi after 20 seconds. Starting WiFi Configuration Portal.");
    startConfigPortal(); // Fallback to AP mode for configuration
  }
}


void loadConfig() {
  Preferences localPrefs;
  bool configLoaded = false; 
  bool prefsWereOpened = localPrefs.begin("assetmon", true); 

  if (prefsWereOpened && localPrefs.isKey("cfg")) {
    char tempConfigBuffer[sizeof(Config) + 128]; // Increased buffer slightly for future-proofing
    size_t len = localPrefs.getBytes("cfg", tempConfigBuffer, sizeof(tempConfigBuffer));

    if (len > 0 && len <= sizeof(Config)) { 
      memcpy(&config, tempConfigBuffer, len); 
      if (len < sizeof(Config)) {
        Serial.println("loadConfig: Loaded config is smaller than current struct. Initializing new/trailing fields.");
        char* newFieldsStart = (char*)&config + len;
        size_t newFieldsSize = sizeof(Config) - len;
        memset(newFieldsStart, 0, newFieldsSize); 

        // Sensible defaults for potentially new fields if not covered by memset(0) or needing specific values
        // This primarily targets the shift configuration if it was added.
        bool recheckShiftDefaults = false;
        // Check if the part of the struct containing shift info was part of the uninitialized (memset) block
        if ((char*)&config.enableShiftArchiving >= newFieldsStart) {
            recheckShiftDefaults = true;
        }

        if (recheckShiftDefaults) {
             config.enableShiftArchiving = false; 
             config.numShifts = 3; 
             strcpy(config.shifts[0].startTime, "06:00");
             strcpy(config.shifts[1].startTime, "14:00");
             strcpy(config.shifts[2].startTime, "22:00");
             for(uint8_t i = config.numShifts; i < MAX_CONFIGURABLE_SHIFTS; ++i) {
                 strcpy(config.shifts[i].startTime, "00:00");
             }
             Serial.println("loadConfig: Applied default values for new shift config fields after struct upgrade.");
        }
      }
      configLoaded = true;
      Serial.println("loadConfig: Configuration loaded from Preferences.");
    } else if (len > sizeof(Config)) {
      Serial.println("loadConfig: Saved config is LARGER than current struct! Possible corruption or version issue. Using defaults.");
      configLoaded = false; 
    } else { 
      Serial.println("loadConfig: Config read error (len=0 or other). Using defaults.");
      configLoaded = false;
    }
  }

  if (!configLoaded) {
    Serial.println("loadConfig: No 'cfg' key or load error. Using defaults and saving.");
    config.assetCount = 2; 
    config.maxEvents = 1000;
    strcpy(config.assets[0].name, "Line 1"); config.assets[0].pin = 4;
    strcpy(config.assets[1].name, "Line 2"); config.assets[1].pin = 12;
    for (uint8_t i = config.assetCount; i < MAX_ASSETS; ++i) { strcpy(config.assets[i].name, ""); config.assets[i].pin = 0; }
    for (int i = 0; i < 5; ++i) { strncpy(config.downtimeReasons[i], DEFAULT_DOWNTIME_REASONS[i], 31); config.downtimeReasons[i][31] = '\0';}
    config.tzOffset = 0; config.longStopThresholdSec = 300; config.monitoringMode = MONITORING_MODE_PARALLEL;
    
    config.enableShiftArchiving = false;
    config.numShifts = 3; 
    strcpy(config.shifts[0].startTime, "06:00");
    strcpy(config.shifts[1].startTime, "14:00");
    strcpy(config.shifts[2].startTime, "22:00");
    for (uint8_t i = config.numShifts; i < MAX_CONFIGURABLE_SHIFTS; ++i) { strcpy(config.shifts[i].startTime, "00:00"); }
    
    if(prefsWereOpened) localPrefs.end(); 
    saveConfig(); // saveConfig will open prefs for write
  }
  
  // Final validation pass on critical config values, especially shifts
  if (config.assetCount == 0 || config.assetCount > MAX_ASSETS) config.assetCount = 1;
  if (config.maxEvents < 100) config.maxEvents = 100;
  if (config.enableShiftArchiving) {
      if (config.numShifts == 0 || config.numShifts > MAX_CONFIGURABLE_SHIFTS) {
          config.numShifts = (config.numShifts == 0 && MAX_CONFIGURABLE_SHIFTS > 0) ? 1 : MAX_CONFIGURABLE_SHIFTS; 
          Serial.printf("loadConfig: Corrected numShifts to %u for enabled archiving.\n", config.numShifts);
      }
      // Ensure all active shift start times are valid HH:MM format
      for (uint8_t i = 0; i < config.numShifts; i++) {
          if (strlen(config.shifts[i].startTime) != 5 || config.shifts[i].startTime[2] != ':') {
              Serial.printf("loadConfig: Invalid time format for shift %d ('%s'). Defaulting to 00:00.\n", i + 1, config.shifts[i].startTime);
              strcpy(config.shifts[i].startTime, "00:00"); // A safe default, user should reconfigure
          }
      }
  } else {
      // If archiving is disabled, numShifts value is less critical but ensure it's not out of bounds if accessed
      if (config.numShifts > MAX_CONFIGURABLE_SHIFTS) config.numShifts = 0;
  }

  if(prefsWereOpened && localPrefs.freeEntries() > 0 ) localPrefs.end();
  
  Serial.printf("Shift Archiving: %s, Num Shifts: %u\n", config.enableShiftArchiving ? "Yes" : "No", config.numShifts);
  if(config.enableShiftArchiving && config.numShifts > 0){
    for(uint8_t i=0; i<config.numShifts; i++){
        Serial.printf("  Shift %u Start: %s\n", i+1, config.shifts[i].startTime);
    }
  }
}

void saveConfig() {
  Preferences localSavePrefs; // Your existing code uses a local Preferences object here

  if (!localSavePrefs.begin("assetmon", false)) { // false for read-write
    Serial.println("saveConfig: Failed to begin preferences for writing.");
    return;
  }

  if (localSavePrefs.putBytes("cfg", &config, sizeof(config)) == sizeof(config)) {
     Serial.println("saveConfig: Configuration saved successfully.");
  } else {
     Serial.println("saveConfig: Error writing configuration to preferences.");
  }
  localSavePrefs.end();
}

void setupTime() {
  // Apply TZ offset from loaded config
  // The format for setenv TZ can be complex for full DST rules.
  // Simple offset: "GMT+/-offset_hours" or "UTC+/-offset_hours"
  // config.tzOffset is in seconds. Convert to hours for standard TZ string.
  // Positive tzOffset means time is AHEAD of UTC (e.g., UTC+2). Standard TZ string is like "ETC/GMT-2".
  // Negative tzOffset means time is BEHIND UTC (e.g., UTC-5). Standard TZ string is like "ETC/GMT+5".
  // So, sign is inverted for the GMT string.
  
  char tzString[20];
  int tzOffsetHours = config.tzOffset / 3600;
  if (tzOffsetHours >= 0) {
    snprintf(tzString, sizeof(tzString), "Etc/GMT-%d", tzOffsetHours);
  } else {
    snprintf(tzString, sizeof(tzString), "Etc/GMT+%d", -tzOffsetHours);
  }
  // For DST, your original hardcoded "GMT0BST,M3.5.0/1,M10.5.0/2" is UK specific.
  // Using a simple offset might be more general if you don't need precise DST for all regions.
  // If you want to keep UK DST:
  // setenv("TZ", "GMT0BST,M3.5.0/1,M10.5.0/2", 1); // UK DST
  // If using tzOffset for a simple offset:
  setenv("TZ", tzString, 1);
  tzset();
  
  // Original NTP config
  configTime(0, 0, "pool.ntp.org", "time.nist.gov"); // Base UTC from NTP

  Serial.print("Waiting for NTP time sync...");
  time_t now_time = time(nullptr);
  int retry = 0;
  // Wait for time to be reasonable (e.g., after 2000, not close to epoch start 1970)
  while (now_time < 1609459200 && retry < 60) { // 1609459200 is Jan 1 2021
    delay(500);
    Serial.print(".");
    now_time = time(nullptr);
    retry++;
  }
  Serial.println(" done");

  if (now_time >= 1609459200) {
    struct tm timeinfo;
    getLocalTime(&timeinfo); // This will apply the TZ environment variable
    Serial.printf("NTP sync successful. Current local time: %s", asctime(&timeinfo));
  } else {
    Serial.println("NTP time sync failed or timed out. Using system boot time (if any). Dates/times may be incorrect.");
  }
}

// V21.ino (Continued - Chunk 5)

// --- New function to log system-wide events (for Serial mode) ---
void logSystemEvent(bool systemIsStarting, time_t now, const char* triggerAssetNameOrReason) {
  if (config.monitoringMode != MONITORING_MODE_SERIAL) return;

  struct tm* ti = localtime(&now);
  char datebuf[11], timebuf[9];
  strftime(datebuf, sizeof(datebuf), "%d/%m/%Y", ti);
  strftime(timebuf, sizeof(timebuf), "%H:%M:%S", ti);

  unsigned long currentTotalRun = g_systemTotalRunningTimeSecs;
  unsigned long currentTotalStop = g_systemTotalStoppedTimeSecs;
  // Note: Durations *leading up to this event* were added in loop().
  // For display at the moment of the event, these are the correct totals *before* this event's impact on future accumulation.

  float sysAvail = (currentTotalRun + currentTotalStop) > 0
                   ? (100.0f * currentTotalRun / (currentTotalRun + currentTotalStop))
                   : (systemIsStarting ? 100.0f : 0.0f);
  float sysRTM_minutes = (float)currentTotalRun / 60.0f;
  float sysSTM_minutes = (float)currentTotalStop / 60.0f;

  float sysMTBF_minutes = (g_systemStopCount > 0)
                          ? ((float)currentTotalRun / g_systemStopCount / 60.0f)
                          : (currentTotalRun > 0 ? sysRTM_minutes : 0.0f);
  float sysMTTR_minutes = (g_systemStopCount > 0)
                          ? ((float)currentTotalStop / g_systemStopCount / 60.0f)
                          : 0.0f;

  String eventName = systemIsStarting ? "SYS_START" : "SYS_STOP";
  String assetColumnValue = "SYSTEM"; // Default for SYS_START
  String noteForLog = "";

  if (!systemIsStarting) { // For SYS_STOP
    assetColumnValue = (triggerAssetNameOrReason && strlen(triggerAssetNameOrReason) > 0) ? triggerAssetNameOrReason : "SYSTEM_WIDE";
    noteForLog = "System Stop Triggered";
    if (triggerAssetNameOrReason && strlen(triggerAssetNameOrReason) > 0 && strcmp(triggerAssetNameOrReason, "SYSTEM_WIDE") != 0 && strcmp(triggerAssetNameOrReason, "SYSTEM") != 0) {
        noteForLog = String("Root Cause: ") + triggerAssetNameOrReason;
    }
  } else { // For SYS_START
    noteForLog = (triggerAssetNameOrReason && strlen(triggerAssetNameOrReason) > 0) ? triggerAssetNameOrReason : "System Recovered";
  }

  File f = SPIFFS.open(LOG_FILENAME, FILE_APPEND);
  if (!f) {
    Serial.println("logSystemEvent: Failed to open log file!");
    return;
  }
  f.printf("%s,%s,%s,%s,%d,%.2f,%.2f,%.2f,%.2f,%.2f,%u,,, %s\n",
           datebuf, timebuf,
           assetColumnValue.c_str(),
           eventName.c_str(),
           systemIsStarting ? 1 : 0,
           sysAvail, sysRTM_minutes, sysSTM_minutes, sysMTBF_minutes, sysMTTR_minutes,
           g_systemStopCount,
           noteForLog.c_str());
  f.close();

  Serial.printf("SYSTEM Event: %s. AssetCol: %s. Note: %s. SysAvail:%.2f, SysStops:%u\n",
                eventName.c_str(), assetColumnValue.c_str(), noteForLog.c_str(), sysAvail, g_systemStopCount);
}

// ============================================================================
// SHIFT LOGIC FUNCTIONS
// ============================================================================

void initializeShiftState() {
  if (!config.enableShiftArchiving || config.numShifts == 0) {
    g_shiftFeatureInitialized = true;
    g_currentShiftIndex = -1; 
    Serial.println("Shift archiving is disabled or no shifts configured.");
    return;
  }

  time_t now = time(nullptr);
  struct tm timeinfo;
  localtime_r(&now, &timeinfo);
  
  int bestMatchIndex = -1;
  time_t latestPassedShiftStartEpoch = 0;

  for (uint8_t i = 0; i < config.numShifts; ++i) {
    int shiftH, shiftM;
    if (sscanf(config.shifts[i].startTime, "%d:%d", &shiftH, &shiftM) == 2) {
      struct tm shift_tm_template = timeinfo; 
      shift_tm_template.tm_hour = shiftH; shift_tm_template.tm_min = shiftM; shift_tm_template.tm_sec = 0;
      time_t currentShiftStartToday = mktime(&shift_tm_template);
      time_t currentShiftStartYesterday = currentShiftStartToday - 86400; 

      if (now >= currentShiftStartToday) {
        if (currentShiftStartToday >= latestPassedShiftStartEpoch) { // Use >= for current day to catch exact start time
          latestPassedShiftStartEpoch = currentShiftStartToday;
          bestMatchIndex = i;
        }
      } else if (now >= currentShiftStartYesterday) { // For shifts that started yesterday and crossed midnight
         if (currentShiftStartYesterday >= latestPassedShiftStartEpoch) { // Use >= here too
          latestPassedShiftStartEpoch = currentShiftStartYesterday;
          bestMatchIndex = i;
        }
      }
    }
  }
  
  if (bestMatchIndex != -1) {
    g_currentShiftIndex = bestMatchIndex;
    g_currentShiftStartTimeEpoch = latestPassedShiftStartEpoch;
    Serial.printf("INITIALIZED. Current Active Shift: #%d (%s). Effective Start Time: %lu\n", 
                  g_currentShiftIndex + 1, config.shifts[g_currentShiftIndex].startTime, (unsigned long)g_currentShiftStartTimeEpoch);
  } else { // Fallback if no logic matched (e.g. bad shift times, or just after midnight before any shift today)
    if (config.numShifts > 0) { // Try to pick the "last" shift from yesterday if applicable
        int latestTimeMinutes = -1;
        int fallbackIndex = 0; // Default to first shift
        for(uint8_t i=0; i<config.numShifts; ++i) {
            int sh, sm;
            if(sscanf(config.shifts[i].startTime, "%d:%d", &sh, &sm) == 2) {
                int currentShiftMinutes = sh * 60 + sm;
                if(currentShiftMinutes > latestTimeMinutes) {
                    latestTimeMinutes = currentShiftMinutes;
                    fallbackIndex = i; // This will be the numerically latest starting shift
                }
            }
        }
        g_currentShiftIndex = fallbackIndex;
        struct tm shift_tm_instance = timeinfo;
        sscanf(config.shifts[g_currentShiftIndex].startTime, "%d:%d", &(shift_tm_instance.tm_hour), &(shift_tm_instance.tm_min));
        shift_tm_instance.tm_sec = 0;
        g_currentShiftStartTimeEpoch = mktime(&shift_tm_instance) - 86400; // Assume it started yesterday
        Serial.printf("INITIALIZED (complex fallback). Active Shift: #%d (%s). Effective Start: %lu\n", 
                  g_currentShiftIndex + 1, config.shifts[g_currentShiftIndex].startTime, (unsigned long)g_currentShiftStartTimeEpoch);
    } else {
        Serial.println("INITIALIZED (no shifts defined). Could not determine active shift.");
        g_currentShiftIndex = -1;
        g_currentShiftStartTimeEpoch = now; 
    }
  }
  g_shiftFeatureInitialized = true;
}

void archiveLogAndResetForShift(int endedShiftIndex, const char* endedShiftStartTimeStr) {
  Serial.printf("Attempting to archive log for ended shift #%d (%s)\n", endedShiftIndex + 1, endedShiftStartTimeStr);
  bool logExistedAndNotEmpty = false;
  if (SPIFFS.exists(LOG_FILENAME)) {
    File logFile = SPIFFS.open(LOG_FILENAME, FILE_READ);
    if (logFile && logFile.size() > 0) { logExistedAndNotEmpty = true; }
    if(logFile) logFile.close();
  }

  if (logExistedAndNotEmpty) {
    if(!SPIFFS.exists("/shiftlogs")) {
        if(SPIFFS.mkdir("/shiftlogs")){ Serial.println("Created /shiftlogs directory"); }
        else { Serial.println("Failed to create /shiftlogs. Archiving to root."); }
    }
    time_t archiveTime = time(nullptr); 
    struct tm timeinfo; localtime_r(&archiveTime, &timeinfo);
    int shiftH_start, shiftM_start; sscanf(endedShiftStartTimeStr, "%d:%d", &shiftH_start, &shiftM_start);
    char newFilename[70];
    snprintf(newFilename, sizeof(newFilename), "/shiftlogs/Log-%04d%02d%02d_%02d%02d-S%d-%02d%02d.csv",
             timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday,
             timeinfo.tm_hour, timeinfo.tm_min, endedShiftIndex + 1, shiftH_start, shiftM_start);
    Serial.printf("Archiving current log to %s\n", newFilename);
    if (SPIFFS.rename(LOG_FILENAME, newFilename)) { Serial.println("Log file archived successfully."); }
    else { Serial.printf("Failed to rename/archive log file to %s.\n", newFilename); }
  } else {
    Serial.printf("Shift %d (%s) ended. Current log file is empty or missing. No archive created.\n", endedShiftIndex + 1, endedShiftStartTimeStr);
  }

  Serial.println("Resetting runtime statistics for new shift period.");
  time_t newShiftActualStartTime = time(nullptr); 
  for (uint8_t i = 0; i < config.assetCount; ++i) {
    if (i < MAX_ASSETS) {
      assetStates[i].sessionStart = newShiftActualStartTime;
      assetStates[i].runningTime = 0; assetStates[i].stoppedTime = 0;
      assetStates[i].runCount = 0; assetStates[i].stopCount = 0;
      if (config.assets[i].pin > 0 && config.assets[i].pin < 40) { assetStates[i].lastState = digitalRead(config.assets[i].pin); }
      else { assetStates[i].lastState = true; }
      assetStates[i].lastChangeTime = newShiftActualStartTime; assetStates[i].lastEventTime = newShiftActualStartTime;
      assetStates[i].lastRunDuration = 0; assetStates[i].lastStopDuration = 0;
      logEvent(i, !assetStates[i].lastState, newShiftActualStartTime, "NEW_SHIFT_START"); 
    }
  }
  if (config.monitoringMode == MONITORING_MODE_SERIAL) {
    g_systemTotalRunningTimeSecs = 0; g_systemTotalStoppedTimeSecs = 0;
    g_systemStopCount = 0; g_systemLastStateChangeTime = newShiftActualStartTime;
    g_systemStateInitialized = false; 
    // System state will be re-evaluated in the main loop based on new asset states
    // For an immediate log:
    // bool anyAssetDown = false; char tempTrigger[32] = "";
    // for (uint8_t k=0; k<config.assetCount; ++k) if(assetStates[k].lastState) { anyAssetDown=true; strncpy(tempTrigger, config.assets[k].name, 31); break;}
    // logSystemEvent(!anyAssetDown, newShiftActualStartTime, anyAssetDown ? tempTrigger : "SYSTEM_SHIFT_START_OK");
  }
  
  File f_newlog = SPIFFS.open(LOG_FILENAME, FILE_APPEND); 
  if(f_newlog){
      struct tm *ti_log = localtime(&newShiftActualStartTime);
      char datebuf_log[11], timebuf_log[9];
      strftime(datebuf_log, sizeof(datebuf_log), "%d/%m/%Y", ti_log);
      strftime(timebuf_log, sizeof(timebuf_log), "%H:%M:%S", ti_log);
      const char* newShiftStartTimeDisplay = (g_currentShiftIndex >=0 && g_currentShiftIndex < config.numShifts) ? config.shifts[g_currentShiftIndex].startTime : "??:??";
      f_newlog.printf("%s,%s,SYSTEM,SHIFT_TRANSITION,,,,,,,,,,Ended Shift #%d (%s). New shift (#%d - %s) started.\n", 
               datebuf_log, timebuf_log, 
               endedShiftIndex + 1, endedShiftStartTimeStr,
               g_currentShiftIndex + 1, newShiftStartTimeDisplay);
      f_newlog.close();
      Serial.println("Logged SHIFT_TRANSITION to new log file.");
  }
}

void processShiftLogic() {
  if (!g_shiftFeatureInitialized || !config.enableShiftArchiving || config.numShifts == 0) { return; }
  static time_t lastShiftCheck = 0; time_t now = time(nullptr);
  if (now < 1609459200) return; // Don't run if time is not synced

  if (now - lastShiftCheck < 58 && lastShiftCheck != 0) { // Check approx once per minute (58 to avoid exact minute skip)
    return;
  }
  lastShiftCheck = now;

  struct tm timeinfo; localtime_r(&now, &timeinfo);
  int newlyDeterminedShiftIndex = -1; time_t newShiftStartTimeEpochThisInstance = 0;
  time_t latestPassedShiftStartEpoch = 0; int tempBestMatchIndex = -1;

  for (uint8_t i = 0; i < config.numShifts; ++i) {
    int shiftH, shiftM;
    if (sscanf(config.shifts[i].startTime, "%d:%d", &shiftH, &shiftM) == 2) {
      struct tm shift_tm_template = timeinfo; 
      shift_tm_template.tm_hour = shiftH; shift_tm_template.tm_min = shiftM; shift_tm_template.tm_sec = 0;
      time_t currentShiftStartToday = mktime(&shift_tm_template);
      time_t currentShiftStartYesterday = currentShiftStartToday - 86400; 
      if (now >= currentShiftStartToday) { // Shift could have started today
        if (currentShiftStartToday >= latestPassedShiftStartEpoch) { 
          latestPassedShiftStartEpoch = currentShiftStartToday;
          tempBestMatchIndex = i;
        }
      } else if (now >= currentShiftStartYesterday) { // Shift must have started yesterday
         if (currentShiftStartYesterday >= latestPassedShiftStartEpoch) {
          latestPassedShiftStartEpoch = currentShiftStartYesterday;
          tempBestMatchIndex = i;
        }
      }
    }
  }
  
  if (tempBestMatchIndex != -1) {
      newlyDeterminedShiftIndex = tempBestMatchIndex;
      newShiftStartTimeEpochThisInstance = latestPassedShiftStartEpoch;
  } else { // Fallback if logic above failed (e.g. bad shift times not covering 24h)
      Serial.println("processShiftLogic: Could not determine current shift based on start times. Using stored index if valid.");
      newlyDeterminedShiftIndex = g_currentShiftIndex; 
      newShiftStartTimeEpochThisInstance = g_currentShiftStartTimeEpoch;
      // If g_currentShiftIndex is also invalid, try to re-initialize (though it should have been done in setup)
      if (g_currentShiftIndex == -1 && config.numShifts > 0) {
          initializeShiftState(); // Try re-initializing
          newlyDeterminedShiftIndex = g_currentShiftIndex; // Use the newly initialized value
          newShiftStartTimeEpochThisInstance = g_currentShiftStartTimeEpoch;
          Serial.printf("processShiftLogic: Re-initialized shift state. New index: %d\n", newlyDeterminedShiftIndex);
      } else if (g_currentShiftIndex == -1){
          Serial.println("processShiftLogic: Fallback failed, no valid shift index.");
          return; // Cannot proceed
      }
  }

  if (g_currentShiftIndex == -1 && newlyDeterminedShiftIndex != -1) { 
    g_currentShiftIndex = newlyDeterminedShiftIndex;
    g_currentShiftStartTimeEpoch = newShiftStartTimeEpochThisInstance;
    Serial.printf("PROCESSLOGIC: Initial active shift set to #%d (%s). Effective Start: %lu\n", 
                  g_currentShiftIndex + 1, config.shifts[g_currentShiftIndex].startTime, (unsigned long)g_currentShiftStartTimeEpoch);
  } else if (newlyDeterminedShiftIndex != -1 && newShiftStartTimeEpochThisInstance > g_currentShiftStartTimeEpoch) {
    Serial.printf("PROCESSLOGIC: Shift change! Old Shift #%d (%s) ended.\n", g_currentShiftIndex + 1, config.shifts[g_currentShiftIndex].startTime);
    int endedShiftIdx = g_currentShiftIndex; 
    String endedShiftStart = String(config.shifts[endedShiftIdx].startTime);
    g_currentShiftIndex = newlyDeterminedShiftIndex; 
    g_currentShiftStartTimeEpoch = newShiftStartTimeEpochThisInstance;
    Serial.printf("PROCESSLOGIC: New Shift #%d (%s) starting. Effective Start: %lu\n", g_currentShiftIndex + 1, config.shifts[g_currentShiftIndex].startTime, (unsigned long)g_currentShiftStartTimeEpoch);
    archiveLogAndResetForShift(endedShiftIdx, endedShiftStart.c_str());
  } else if (newlyDeterminedShiftIndex != -1 && newlyDeterminedShiftIndex != g_currentShiftIndex && newShiftStartTimeEpochThisInstance == g_currentShiftStartTimeEpoch ) {
      Serial.printf("PROCESSLOGIC: Index changed (%d to %d) but start time (%lu) same. Updating index.\n", g_currentShiftIndex +1, newlyDeterminedShiftIndex+1, (unsigned long)newShiftStartTimeEpochThisInstance);
      g_currentShiftIndex = newlyDeterminedShiftIndex; 
  }
}

void setup() {
  Serial.begin(115200);
  Serial.println("\n--- Device Starting (V21 Patched) ---");

  if (!SPIFFS.begin(true)) { Serial.println("SPIFFS.begin() failed! Halting."); return; }
  Serial.println("SPIFFS initialized.");

  // Initialize global prefs object for WiFi (and potentially other uses if refactored)
  if (!prefs.begin("assetmon", false)) { // Open read-write for initial setup if needed
      Serial.println("Global prefs.begin() failed during setup! WiFi saving might fail.");
  } else {
      Serial.println("Global Preferences initialized.");
  }
  // Note: loadConfig and saveConfig in your version use their own local Preferences instances.

  loadConfig(); // Loads 'config' struct, including monitoringMode
  Serial.println("Configuration loaded/initialized.");

  setupWiFiSmart(); // Uses global 'prefs' for SSID/Pass
  setupTime();      // Uses 'config.tzOffset'
  Serial.println("WiFi and Time setup complete.");

  Serial.printf("Initializing %u assets...\n", config.assetCount);
  time_t initialTime = time(nullptr);
  for (uint8_t i = 0; i < config.assetCount; ++i) {
    if (i < MAX_ASSETS) {
      if (config.assets[i].pin > 0 && config.assets[i].pin < 40) { // Basic GPIO validity for common ESP32 pins
          pinMode(config.assets[i].pin, INPUT_PULLUP);
          assetStates[i].lastState = digitalRead(config.assets[i].pin);
      } else {
          Serial.printf("Warning: Asset %s (idx %u) has invalid pin %u. Defaulting to STOPPED state and marking pin unusable.\n", config.assets[i].name, i, config.assets[i].pin);
          assetStates[i].lastState = true; // Default to stopped
          // config.assets[i].pin = 255; // Mark as unusable if needed, though loop logic should also check
      }
      assetStates[i].lastChangeTime = initialTime;
      assetStates[i].sessionStart = initialTime;
      assetStates[i].runningTime = 0; assetStates[i].stoppedTime = 0;
      assetStates[i].runCount = 0; assetStates[i].stopCount = 0;
      assetStates[i].lastEventTime = initialTime;
      assetStates[i].lastRunDuration = 0; assetStates[i].lastStopDuration = 0;
      Serial.printf("Asset %u ('%s', pin %u) init. Pin State: %s (Input means: %s)\n",
                    i, config.assets[i].name, config.assets[i].pin,
                    assetStates[i].lastState ? "HIGH" : "LOW",
                    assetStates[i].lastState ? "STOPPED" : "RUNNING");
    }
  }

  // --- Initialize System State for Serial Mode ---
  if (config.monitoringMode == MONITORING_MODE_SERIAL) {
    g_systemLastStateChangeTime = initialTime;
    bool anyAssetInitiallyStopped = false;
    g_serialSystemTriggerAssetName[0] = '\0';

    for (uint8_t i = 0; i < config.assetCount; ++i) {
      if (i < MAX_ASSETS) {
        bool assetEffectivelyStopped = assetStates[i].lastState;
        // Also consider an asset with an invalid/unconfigured pin as stopped for system evaluation
        if (config.assets[i].pin == 0 || config.assets[i].pin >= 40) { // Assuming pins >= 40 are invalid
             assetEffectivelyStopped = true;
        }
        if (assetEffectivelyStopped) {
            anyAssetInitiallyStopped = true;
            if (g_serialSystemTriggerAssetName[0] == '\0') {
                strncpy(g_serialSystemTriggerAssetName, config.assets[i].name, 31);
                g_serialSystemTriggerAssetName[31] = '\0';
            }
        }
      }
    }
    g_isSystemSerialDown = anyAssetInitiallyStopped;
    g_systemStateInitialized = true;
    Serial.printf("Serial Mode: Initial system state set. System Down: %s. Root Cause: '%s'\n",
                  g_isSystemSerialDown ? "Yes" : "No",
                  g_isSystemSerialDown ? g_serialSystemTriggerAssetName : "N/A");
    
    // Log the initial system state determined at boot
    if (g_isSystemSerialDown) {
        logSystemEvent(false, initialTime, g_serialSystemTriggerAssetName);
    } else {
        logSystemEvent(true, initialTime, "System Initialized - All Assets Up");
    }
  }
  // --- End System State Initialization ---

  server.on("/", HTTP_GET, []() { server.send(200, "text/html", htmlDashboard()); });
  server.on("/dashboard", HTTP_GET, []() { server.send(200, "text/html", htmlDashboard()); });
  server.on("/config", HTTP_GET, []() { server.send(200, "text/html", htmlConfig()); });
  server.on("/events", HTTP_GET, sendHtmlEventsPage);
  server.on("/asset", HTTP_GET, []() {
    if (server.hasArg("idx")) {
      uint8_t idx = server.arg("idx").toInt();
      if (idx < config.assetCount && idx < MAX_ASSETS) { server.send(200, "text/html", htmlAssetDetail(idx)); return; }
    }
    server.send(404, "text/plain", "Asset not found");
  });

  server.on("/analytics", HTTP_GET, []() { server.send(200, "text/html", htmlAnalytics()); });
  server.on("/analytics-compare", HTTP_GET, []() { server.send(200, "text/html", htmlAnalyticsCompare()); });
  server.on("/reconfigure_wifi", HTTP_POST, handleWiFiReconfigurePost);
  server.on("/save_config", HTTP_POST, handleConfigPost); // Changed from /config_save
  server.on("/clear_log", HTTP_POST, handleClearLog);    // Changed from /clearlog (GET)
  server.on("/export_log", HTTP_GET, handleExportLog);  // Was /exportlog
  server.on("/api/summary", HTTP_GET, handleApiSummary);
  server.on("/api/events", HTTP_GET, handleApiEvents);
  server.on("/api/config", HTTP_GET, handleApiConfig);
  server.on("/api/note", HTTP_POST, handleApiNote); // Was /api/note_update
  server.onNotFound(handleNotFound);

  server.begin();
  Serial.println("Web server started. Device is ready.");
}

void loop() {
  server.handleClient();

  // --- ADD THIS BLOCK for Shift Logic ---
  if (config.enableShiftArchiving && g_shiftFeatureInitialized) {
    processShiftLogic();
  }
  // --- END Shift Logic Block ---

  time_t now = time(nullptr); // This 'now' is used by the rest of your original loop logic

  // --- I. Individual Asset State Monitoring & Event Logging ---
  for (uint8_t i = 0; i < config.assetCount; ++i) {
    if (i >= MAX_ASSETS) continue;

    // Determine current pin state, defaulting to STOPPED if pin is invalid
    bool current_pin_state = true; // Assume stopped
    if (config.assets[i].pin > 0 && config.assets[i].pin < 40) { // Valid pin range
        current_pin_state = digitalRead(config.assets[i].pin); // true if HIGH (STOPPED)
    } else {
        // For assets with invalid pins, their lastState should remain true (STOPPED)
        // and they shouldn't trigger a state change log event unless their configured pin changes.
        // We ensure assetStates[i].lastState reflects this expectation.
        if (assetStates[i].lastState == false) { // If it was somehow marked running with an invalid pin
             assetStates[i].lastState = true;    // Correct it to stopped
             assetStates[i].lastChangeTime = now; // And mark the change time
        }
        // Skip further processing for this asset in parallel mode if pin is invalid
        if (config.monitoringMode == MONITORING_MODE_PARALLEL) continue; 
        // In serial mode, an invalid pin means this asset is considered "stopped" for system evaluation
    }
    
    if (current_pin_state != assetStates[i].lastState) {
      unsigned long elapsed = now - assetStates[i].lastChangeTime;
      unsigned long runDuration = 0;
      unsigned long stopDuration = 0;
      char eventNoteBuffer[128] = ""; // For "Consequence Stop"

      if (current_pin_state == true) { // Machine just STOPPED (was running)
        assetStates[i].runningTime += elapsed;
        assetStates[i].stopCount++;
        runDuration = elapsed;
        assetStates[i].lastRunDuration = runDuration;
        assetStates[i].lastStopDuration = 0;

        if (config.monitoringMode == MONITORING_MODE_SERIAL && g_isSystemSerialDown &&
            strlen(g_serialSystemTriggerAssetName) > 0 &&
            strcmp(config.assets[i].name, g_serialSystemTriggerAssetName) != 0) {
          snprintf(eventNoteBuffer, sizeof(eventNoteBuffer), "Consequence Stop (System: %s)", g_serialSystemTriggerAssetName);
        }
        logEvent(i, false, now, eventNoteBuffer[0] ? eventNoteBuffer : nullptr, runDuration, 0);
      
      } else { // Machine just STARTED (was stopped)
        assetStates[i].stoppedTime += elapsed;
        assetStates[i].runCount++;
        stopDuration = elapsed;
        assetStates[i].lastStopDuration = stopDuration;
        assetStates[i].lastRunDuration = 0;
        logEvent(i, true, now, nullptr, 0, stopDuration);
      }
      assetStates[i].lastState = current_pin_state;
      assetStates[i].lastChangeTime = now;
    }
  } // End of individual asset loop

  // --- II. System State Logic (Serial Mode Only) ---
  if (config.monitoringMode == MONITORING_MODE_SERIAL) {
    if (!g_systemStateInitialized) { // Should have been initialized in setup
        g_systemLastStateChangeTime = now;
        bool anyAssetInitiallyStoppedLoop = false;
        g_serialSystemTriggerAssetName[0] = '\0';
        for (uint8_t k = 0; k < config.assetCount; ++k) {
            if (k < MAX_ASSETS) {
                bool assetEffectivelyStoppedLoop = assetStates[k].lastState;
                 if (config.assets[k].pin == 0 || config.assets[k].pin >= 40) { // Also consider invalid pins as stopped
                    assetEffectivelyStoppedLoop = true;
                 }
                if (assetEffectivelyStoppedLoop) {
                    anyAssetInitiallyStoppedLoop = true;
                    if (g_serialSystemTriggerAssetName[0] == '\0') {
                        strncpy(g_serialSystemTriggerAssetName, config.assets[k].name, 31);
                        g_serialSystemTriggerAssetName[31] = '\0';
                    }
                }
            }
        }
        g_isSystemSerialDown = anyAssetInitiallyStoppedLoop;
        g_systemStateInitialized = true;
        Serial.println("Serial Mode: System state re-initialized in loop (fallback).");
        logSystemEvent(!g_isSystemSerialDown, now, g_isSystemSerialDown ? g_serialSystemTriggerAssetName : "System Initialized - All Up (Loop)");
    }

    bool isAnyAssetCurrentlyStopped = false;
    char currentCycleTriggerAssetName[32] = ""; 
    currentCycleTriggerAssetName[0] = '\0';

    for (uint8_t j = 0; j < config.assetCount; ++j) {
      if (j < MAX_ASSETS) {
        bool assetEffectivelyStopped = assetStates[j].lastState;
        // An asset with an invalid/unconfigured pin is considered "stopped" for system evaluation
        if (config.assets[j].pin == 0 || config.assets[j].pin >= 40) { 
             assetEffectivelyStopped = true;
        }

        if (assetEffectivelyStopped) {
          isAnyAssetCurrentlyStopped = true;
          if (currentCycleTriggerAssetName[0] == '\0') { // Capture the first stopped asset
            strncpy(currentCycleTriggerAssetName, config.assets[j].name, 31);
            currentCycleTriggerAssetName[31] = '\0';
          }
        }
      }
    }

    // Handle System Transition to DOWN
    if (isAnyAssetCurrentlyStopped && !g_isSystemSerialDown) {
      unsigned long systemUpDuration = now - g_systemLastStateChangeTime;
      g_systemTotalRunningTimeSecs += systemUpDuration;
      g_isSystemSerialDown = true;
      g_systemLastStateChangeTime = now;
      g_systemStopCount++;
      strncpy(g_serialSystemTriggerAssetName, currentCycleTriggerAssetName, 31); 
      g_serialSystemTriggerAssetName[31] = '\0';
      if (strlen(g_serialSystemTriggerAssetName) == 0 && isAnyAssetCurrentlyStopped) strcpy(g_serialSystemTriggerAssetName, "Unknown"); // Fallback
      logSystemEvent(false, now, g_serialSystemTriggerAssetName);
      Serial.printf("Serial Mode: System -> DOWN. Root Cause: %s. Up Duration: %lu s\n", g_serialSystemTriggerAssetName, systemUpDuration);
    }
    // Handle System Transition to UP
    else if (!isAnyAssetCurrentlyStopped && g_isSystemSerialDown) {
      unsigned long systemDownDuration = now - g_systemLastStateChangeTime;
      g_systemTotalStoppedTimeSecs += systemDownDuration;
      g_isSystemSerialDown = false;
      g_systemLastStateChangeTime = now;
      g_serialSystemTriggerAssetName[0] = '\0';
      logSystemEvent(true, now, "All Assets Recovered");
      Serial.printf("Serial Mode: System -> UP. Down Duration: %lu s\n", systemDownDuration);
    }
  }
  delay(200); // Main loop delay
}

// logEvent: Accepts customNote for "Consequence Stop"
void logEvent(uint8_t assetIdx, bool machineIsRunning, time_t now, const char* customNote, unsigned long runDuration, unsigned long stopDuration) {
  if (assetIdx >= MAX_ASSETS) return;

  AssetState& as = assetStates[assetIdx];
  // Cumulative stats are updated *before* this event for calculation of metrics *at the time of this event*
  unsigned long cumulative_runningTime = as.runningTime;
  unsigned long cumulative_stoppedTime = as.stoppedTime;

  // If this event is a STOP, the runDuration that just ENDED is added to cumulative_runningTime for MTBF calc
  // If this event is a START, the stopDuration that just ENDED is added to cumulative_stoppedTime for MTTR calc
  // The assetStates[i].runningTime/stoppedTime in loop() are updated *before* calling logEvent.

  float avail = (cumulative_runningTime + cumulative_stoppedTime) > 0
                ? (100.0 * cumulative_runningTime / (cumulative_runningTime + cumulative_stoppedTime))
                : (machineIsRunning ? 100.0 : 0.0);

  float total_runtime_min = cumulative_runningTime / 60.0;
  float total_downtime_min = cumulative_stoppedTime / 60.0;

  // as.stopCount is the count of *completed* stop cycles.
  // If this is a STOP event, stopCount has just been incremented in loop()
  // If this is a START event, stopCount reflects stops before this run.
  uint32_t stops_for_mtbf_calc = machineIsRunning ? as.stopCount : as.stopCount; // if running, use current stopCount for MTBF of runs ending in those stops
                                                                                   // if stopping, stopCount was just incremented, use that.
  uint32_t stops_for_mttr_calc = as.stopCount; // MTTR is based on completed stop cycles.

  float mtbf_val = (stops_for_mtbf_calc > 0) ? (float)cumulative_runningTime / stops_for_mtbf_calc / 60.0 : total_runtime_min;
  float mttr_val = (stops_for_mttr_calc > 0) ? (float)cumulative_stoppedTime / stops_for_mttr_calc / 60.0 : 0;

  struct tm * ti = localtime(&now);
  char datebuf[11], timebuf[9];
  strftime(datebuf, sizeof(datebuf), "%d/%m/%Y", ti);
  strftime(timebuf, sizeof(timebuf), "%H:%M:%S", ti);

  File f = SPIFFS.open(LOG_FILENAME, FILE_APPEND);
  if (!f) { Serial.println("Failed to open log file for writing!"); return; }
  f.printf("%s,%s,%s,%s,%d,%.2f,%.2f,%.2f,%.2f,%.2f,%u,%s,%s,%s\n",
    datebuf, timebuf, config.assets[assetIdx].name,
    machineIsRunning ? "START" : "STOP",
    machineIsRunning ? 1 : 0,
    avail, total_runtime_min, total_downtime_min, mtbf_val, mttr_val,
    as.stopCount, // Log the current stop count of the asset
    (runDuration > 0 ? formatMMSS(runDuration).c_str() : ""),
    (stopDuration > 0 ? formatMMSS(stopDuration).c_str() : ""),
    customNote ? customNote : "" // Use customNote if provided
  );
  f.close();
  as.lastEventTime = now;
  Serial.printf("Event logged for %s: %s. Note: '%s'. RunD: %s, StopD: %s. Stops: %u\n",
    config.assets[assetIdx].name, machineIsRunning ? "START" : "STOP",
    customNote ? customNote : "",
    formatMMSS(runDuration).c_str(), formatMMSS(stopDuration).c_str(), as.stopCount
  );
}

String formatMMSS(unsigned long seconds) {
  if (seconds == 0) return ""; // Return empty for 0, or "00:00" if you prefer
  unsigned int min_val = seconds / 60;
  unsigned int sec_val = seconds % 60;
  char buf[8]; // "MM:SS" + null
  sprintf(buf, "%02u:%02u", min_val, sec_val);
  return String(buf);
}

// eventToCSV, urlEncode, urlDecode - no changes from your V21
String eventToCSV(const Event& e) {
  struct tm * ti = localtime(&e.timestamp);
  char datebuf[16], timebuf[16];
  strftime(datebuf, sizeof(datebuf), "%d/%m/%Y", ti);
  strftime(timebuf, sizeof(timebuf), "%H:%M:%S", ti);

  String csv = String(datebuf) + "," + String(timebuf) + "," +
               String(e.assetName) + "," + String(e.eventType) + "," +
               String(e.state) + "," + String(e.availability, 2) + "," +
               String(e.runtime, 2) + "," + String(e.downtime, 2) + "," +
               String(e.mtbf, 2) + "," + String(e.mttr, 2) + "," +
               String(e.stops) + "," +
               String(e.runDuration) + "," + String(e.stopDuration) + "," +
               String(e.note);
  return csv;
}

String urlEncode(const String& str) {
  String encodedString = ""; char c; char code0; char code1;
  for (unsigned int i = 0; i < str.length(); i++) {
    c = str.charAt(i);
    if (c == ' ') encodedString += '+';
    else if (isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~') encodedString += c;
    else {
      code1 = (c & 0xf) + '0'; if ((c & 0xf) > 9) code1 = (c & 0xf) - 10 + 'A';
      c = (c >> 4) & 0xf; code0 = c + '0'; if (c > 9) code0 = c - 10 + 'A';
      encodedString += '%'; encodedString += code0; encodedString += code1;
    }
  }
  return encodedString;
}
String urlDecode(const String& str) {
  String decoded = ""; char temp[] = "0x00"; unsigned int len = str.length(); unsigned int i = 0;
  while (i < len) {
    char c = str.charAt(i);
    if (c == '%') {
      if (i+2 < len) { temp[2] = str.charAt(i+1); temp[3] = str.charAt(i+2); decoded += char(strtol(temp, NULL, 16)); i += 3; }
      else { i++; } // Incomplete escape, skip
    } else if (c == '+') { decoded += ' '; i++; }
    else { decoded += c; i++; }
  }
  return decoded;
}

// V21.ino (Continued - Chunk 8: HTML Functions)

String htmlConfig() {
  String html = "<!DOCTYPE html><html lang='en'><head><title>Setup</title><meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<link href='https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap' rel='stylesheet'>";
  html += "<link href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css' rel='stylesheet'>";
  // Using your original CSS for this page, but ensuring Bootstrap compatibility for new elements.
  html += "<style>";
  html += "body{font-family:Roboto,sans-serif;background:#f3f7fa;margin:0;}";
  html += "header{background:#1976d2;color:#fff;padding:1.2rem 0;text-align:center;box-shadow:0 2px 10px #0001; font-size:1.6em; font-weight:700;}"; // Your original header style
  html += ".nav{display:flex;justify-content:center;gap:1rem;margin:1rem 0;flex-wrap:wrap;align-items:center;}"; // Your original nav container style
  html += ".nav button, .nav a {text-decoration:none;background:#fff;color:#1976d2;border:1px solid #1976d2;border-radius:6px;padding:0.7em 1.1em;font-size:1.1em;font-weight:700;box-shadow:0 2px 8px #0001;cursor:pointer;margin:0.2em 0.4em;}"; // Adjusted for Bootstrap button look
  html += ".nav button:hover, .nav a:hover {background:#e3f0fc;}";
  html += ".nav .right{margin-left:auto;}";
  html += ".main{max-width:700px;margin:1rem auto;padding:1rem;}";
  html += ".card{background:#fff;border-radius:10px;box-shadow:0 2px 16px #0002;margin-bottom:1.3rem;padding:1.3rem;}";
  // Bootstrap form styling will largely take over from these for new elements
  html += "label.form-label{font-weight:500;margin-top:1em;display:block;}"; // Ensure labels are styled correctly
  html += "input.form-control[type=text],input.form-control[type=number],select.form-select{width:100%;padding:0.6em;margin-top:0.2em;margin-bottom:1em;border:1px solid #ccc;border-radius:5px;font-size:1em;}";
  html += "button.btn-primary, input.btn-primary[type=submit]{width:100%;margin-top:1em;padding:0.8em 1.5em;font-size:1.15em;font-weight:700;}"; // Bootstrap button styling
  html += ".notice{background:#e6fbe7;color:#256029;font-weight:bold;padding:0.6em 1em;border-radius:7px;margin-bottom:1em;text-align:center;}";
  // Styles for Bootstrap accordion
  html += ".accordion-button:not(.collapsed){color: #0c63e4; background-color: #e7f1ff;}";
  html += ".accordion-button:focus {box-shadow: 0 0 0 .25rem rgba(13,110,253,.25);}";
  html += "</style>";
  html += "</head><body>";

  // Using Bootstrap Navbar for consistency
  html += "<nav class='navbar navbar-expand-lg navbar-dark bg-dark shadow-sm'>";
  html += "  <div class='container-fluid'>";
  html += "    <a class='navbar-brand' href='/'>Asset Availability</a>";
  html += "    <button class='navbar-toggler' type='button' data-bs-toggle='collapse' data-bs-target='#navbarNav'><span class='navbar-toggler-icon'></span></button>";
  html += "    <div class='collapse navbar-collapse' id='navbarNav'>";
  html += "      <ul class='navbar-nav ms-auto'>";
  html += "        <li class='nav-item'><a class='nav-link' href='/'>Dashboard</a></li>";
  html += "        <li class='nav-item'><a class='nav-link' href='/events'>Event Log</a></li>";
  html += "        <li class='nav-item'><a class='nav-link' href='/analytics-compare'>Compare Assets</a></li>";
  html += "        <li class='nav-item'><a class='nav-link active' href='/config'>Setup</a></li>";
  html += "      </ul>";
  html += "    </div>";
  html += "  </div>";
  html += "</nav>";

  html += "<div class='container mt-4'>"; // Bootstrap container for main content
  html += "  <div class='row justify-content-center'>";
  html += "    <div class='col-lg-9 col-xl-8'>"; // Slightly wider column for more space

  html += "      <div class='card shadow-sm'>";
  html += "        <div class='card-header bg-light'><h3 class='mb-0'>Configuration</h3></div>";
  html += "        <div class='card-body'>";
  html += "          <div id='saveNotice' class='alert alert-success' style='display:none;'>Settings saved! Device is rebooting...</div>";
  html += "          <form method='POST' action='/save_config' id='setupform' onsubmit='setTimeout(() => { const notice = document.getElementById(\"saveNotice\"); if(notice) notice.style.display=\"block\"; }, 500);'>";
  
  html += "            <div class='accordion' id='configAccordion'>";
  
  // --- Accordion Item: Asset Setup ---
  html += "              <div class='accordion-item'>";
  html += "                <h2 class='accordion-header' id='headingAssets'><button class='accordion-button' type='button' data-bs-toggle='collapse' data-bs-target='#collapseAssets' aria-expanded='true' aria-controls='collapseAssets'>Asset Setup</button></h2>";
  html += "                <div id='collapseAssets' class='accordion-collapse collapse show' aria-labelledby='headingAssets' data-bs-parent='#configAccordion'><div class='accordion-body'>";
  html += "                  <div class='mb-3'><label for='assetCountField' class='form-label'>Asset Count (1-" + String(MAX_ASSETS) + ")</label><input type='number' class='form-control' id='assetCountField' name='assetCount' min='1' max='" + String(MAX_ASSETS) + "' value='" + String(config.assetCount) + "' required></div>";
  html += "                  <p class='form-text'>After changing asset count, 'Save All Settings & Reboot'. The page will then update to show fields for each asset.</p>";
  for (uint8_t i = 0; i < config.assetCount; ++i) {
    if (i >= MAX_ASSETS) break;
    html += "                  <fieldset class='border p-3 mb-3 rounded bg-light-subtle'><legend class='w-auto px-2 fs-6 fw-semibold'>Asset #" + String(i + 1) + "</legend>";
    html += "                    <div class='mb-3'><label for='name" + String(i) + "' class='form-label'>Name</label><input type='text' class='form-control' id='name" + String(i) + "' name='name" + String(i) + "' value='" + String(config.assets[i].name) + "' maxlength='31' required></div>";
    html += "                    <div><label for='pin" + String(i) + "' class='form-label'>GPIO Pin</label><input type='number' class='form-control' id='pin" + String(i) + "' name='pin" + String(i) + "' value='" + String(config.assets[i].pin) + "' min='0' max='39' required></div>";
    html += "                  </fieldset>";
  }
  html += "                </div></div>";
  html += "              </div>";

  // --- Accordion Item: Operational Settings ---
  html += "              <div class='accordion-item'>";
  html += "                <h2 class='accordion-header' id='headingOps'><button class='accordion-button collapsed' type='button' data-bs-toggle='collapse' data-bs-target='#collapseOps' aria-expanded='false' aria-controls='collapseOps'>Operational Settings</button></h2>";
  html += "                <div id='collapseOps' class='accordion-collapse collapse' aria-labelledby='headingOps' data-bs-parent='#configAccordion'><div class='accordion-body'>";
  html += "                  <div class='mb-3'><label for='maxEvents' class='form-label'>Max Events in Log</label><input type='number' id='maxEvents' class='form-control' name='maxEvents' min='100' max='5000' value='" + String(config.maxEvents) + "' required></div>";
  html += "                  <div class='mb-3'><label for='tzOffset' class='form-label'>Timezone Offset (hours from UTC)</label><input type='number' id='tzOffset' class='form-control' name='tzOffset' min='-12' max='14' step='0.5' value='" + String(config.tzOffset / 3600.0, 1) + "' required></div>";
  html += "                  <div class='mb-3'><label for='longStopThreshold' class='form-label'>Highlight Stops Longer Than (minutes)</label><input type='number' id='longStopThreshold' class='form-control' name='longStopThreshold' min='1' max='1440' value='" + String(config.longStopThresholdSec/60) + "' required></div>";
  html += "                  <div><label for='monitoringMode' class='form-label'>Monitoring Mode</label><select id='monitoringMode' name='monitoringMode' class='form-select'>";
  html += "                    <option value='" + String(MONITORING_MODE_PARALLEL) + "'" + (config.monitoringMode == MONITORING_MODE_PARALLEL ? " selected" : "") + ">Parallel (Assets Independent)</option>";
  html += "                    <option value='" + String(MONITORING_MODE_SERIAL) + "'" + (config.monitoringMode == MONITORING_MODE_SERIAL ? " selected" : "") + ">Serial (System Stops if Any Asset Stops)</option>";
  html += "                  </select></div>";
  html += "                </div></div>";
  html += "              </div>";
  
  // --- NEW ACCORDION ITEM: Production Shift Setup ---
  html += "              <div class='accordion-item'>";
  html += "                <h2 class='accordion-header' id='headingShifts'><button class='accordion-button collapsed' type='button' data-bs-toggle='collapse' data-bs-target='#collapseShifts' aria-expanded='false' aria-controls='collapseShifts'>Production Data & Shift Setup</button></h2>";
  html += "                <div id='collapseShifts' class='accordion-collapse collapse' aria-labelledby='headingShifts' data-bs-parent='#configAccordion'><div class='accordion-body'>";
  html += "                  <div class='form-check mb-3'><input class='form-check-input' type='checkbox' name='enableShiftArchiving' id='enableShiftArchiving' value='1'" + String(config.enableShiftArchiving ? " checked" : "") + " onchange='toggleShiftSettingsDisplay(this.checked)'><label class='form-check-label' for='enableShiftArchiving'>Enable Automatic Log Archival & Clearing per Shift</label></div>";
  html += "                  <div id='shiftSettingsBlockGlobal'" + String(config.enableShiftArchiving ? "" : " style='display:none;'") +">";
  html += "                    <div class='mb-3'><label for='numShiftsInput' class='form-label'>Number of Shifts (1-" + String(MAX_CONFIGURABLE_SHIFTS) + ")</label><input type='number' class='form-control' name='numShifts' id='numShiftsInput' min='1' max='" + String(MAX_CONFIGURABLE_SHIFTS) + "' value='" + String(config.numShifts > 0 ? config.numShifts : 1) + "' oninput='renderShiftTimeInputs(this.value)'></div>";
  html += "                    <div id='shiftTimeInputsContainer'>";
  // C++ loop to render existing shift time inputs based on config
  if (config.enableShiftArchiving) {
    for(uint8_t i = 0; i < config.numShifts; ++i) {
      if (i < MAX_CONFIGURABLE_SHIFTS) {
        html += "                  <div class='mb-3'><label for='shiftStartTime" + String(i) + "' class='form-label'>Shift " + String(i + 1) + " Start Time (HH:MM)</label><input type='time' class='form-control' id='shiftStartTime" + String(i) + "' name='shiftStartTime" + String(i) + "' value='" + String(config.shifts[i].startTime) + "' required></div>";
      }
    }
  }
  html += "                    </div>"; // End shiftTimeInputsContainer
  html += "                    <p class='form-text'>Define the start time for each shift (e.g., 06:00, 14:00, 22:00). Ensure times are in chronological order for correct operation. Logs are archived at the detected start of a new shift.</p>";
  html += "                  </div>"; // End shiftSettingsBlockGlobal
  html += "                </div></div>";
  html += "              </div>";
  // --- END NEW ACCORDION ITEM ---
  
  // --- Accordion Item: Downtime Reasons ---
  html += "              <div class='accordion-item'>";
  html += "                <h2 class='accordion-header' id='headingReasons'><button class='accordion-button collapsed' type='button' data-bs-toggle='collapse' data-bs-target='#collapseReasons' aria-expanded='false' aria-controls='collapseReasons'>Downtime Quick Reasons</button></h2>";
  html += "                <div id='collapseReasons' class='accordion-collapse collapse' aria-labelledby='headingReasons' data-bs-parent='#configAccordion'><div class='accordion-body'>";
  for (int i = 0; i < 5; ++i) {
    html += "                  <div class='mb-3'><label for='reason" + String(i) + "' class='form-label'>Reason " + String(i+1) + "</label><input type='text' class='form-control' id='reason" + String(i) + "' name='reason" + String(i) + "' value='" + String(config.downtimeReasons[i]) + "' maxlength='31'></div>";
  }
  html += "                </div></div>";
  html += "              </div>";

  html += "            </div>"; // End Accordion
  html += "            <div class='d-grid gap-2 mt-4'><button type='submit' class='btn btn-primary btn-lg'>Save All Settings & Reboot</button></div>";
  html += "          </form>";
  html += "        </div>"; 
  html += "      </div>"; 

  html += "      <div class='card shadow-sm mt-4'><div class='card-header bg-light'><h4 class='mb-0'>System Actions</h4></div><div class='card-body'>";
  html += "        <p>Current WiFi: <strong>" + (WiFi.status() == WL_CONNECTED ? WiFi.SSID() + " (IP: " + WiFi.localIP().toString() + ")" : "Not Connected / AP Mode") + "</strong></p>";
  html += "        <form method='POST' action='/reconfigure_wifi' onsubmit='return confirm(\"Enter WiFi setup mode? Device will restart as an Access Point.\");' class='d-grid gap-2 mb-3'><button type='submit' class='btn btn-warning'>Reconfigure WiFi</button></form>";
  html += "        <form method='POST' action='/clear_log' onsubmit='return confirm(\"Are you sure you want to CLEAR THE CURRENT EVENT LOG? Archived shift logs will not be affected. This cannot be undone!\");' class='d-grid gap-2'><button type='submit' class='btn btn-danger'>Clear Current Event Log</button></form>";
  html += "      </div></div>";

  html += "    </div>"; 
  html += "  </div>"; 
  html += "</div>"; 

  html += "<script>";
  html += R"rawliteral(
    function toggleShiftSettingsDisplay(enabled) {
      document.getElementById('shiftSettingsBlockGlobal').style.display = enabled ? 'block' : 'none';
    }

    function renderShiftTimeInputs(numShiftsStr) {
      const num = parseInt(numShiftsStr, 10);
      const container = document.getElementById('shiftTimeInputsContainer');
      const currentConfiguredShifts = container.querySelectorAll('input[name^="shiftStartTime"]').length;
      
      // Clear previous dynamically added inputs, but respect ones rendered by C++ for initial load
      // This simple version just redraws everything.
      container.innerHTML = ''; 

      const maxShifts = )rawliteral" + String(MAX_CONFIGURABLE_SHIFTS) + R"rawliteral(;
      if (isNaN(num) || num < 1 || num > maxShifts) {
        // If user types an invalid number, cap it or show an error.
        // For now, we just don't render if out of bounds from manual typing.
        // The input field itself has min/max attributes.
        return;
      }

      for (let i = 0; i < num; i++) {
        const shiftDiv = document.createElement('div');
        shiftDiv.classList.add('mb-3');
        // Try to get existing value if it was there (e.g. C++ rendered it)
        // This is simplified; actual values are best handled on ESP side for initial render.
        let existingValue = ""; // Placeholder for potential pre-fill from already rendered field if logic was more complex
                                // For now, new fields from JS will be blank or default to "00:00"
        shiftDiv.innerHTML = `
          <label class="form-label">Shift ${i + 1} Start Time (HH:MM)</label>
          <input type="time" class="form-control" name="shiftStartTime${i}" value="${existingValue || '00:00'}" required>`;
        container.appendChild(shiftDiv);
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
      const enableCheckbox = document.getElementById('enableShiftArchiving');
      if (enableCheckbox) {
        toggleShiftSettingsDisplay(enableCheckbox.checked);
      }
      // The C++ loop now renders the initial shift fields based on config.numShifts,
      // so no need for an initial JS call to renderShiftTimeInputs if enableShiftArchiving is checked.
      // The oninput handler for numShiftsInput will allow dynamic changes.
    });
  )rawliteral";
  html += "</script>";
  html += "<script src='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js'></script>";
  html += "</body></html>";
  return html;
}

String htmlDashboard() {
  String html = "<!DOCTYPE html><html lang='en'><head><title>Dashboard</title>";
  html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<link href='https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap' rel='stylesheet'>";
  html += "<link href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css' rel='stylesheet'>";
  html += "<script src='https://cdn.jsdelivr.net/npm/chart.js'></script>";
  html += "<style>body{background-color:#f8f9fa;}</style>";
  html += "</head><body>";

  // --- Standard Bootstrap Navbar ---
  html += "<nav class='navbar navbar-expand-lg navbar-dark bg-dark shadow-sm'>";
  html += "  <div class='container-fluid'>";
  html += "    <a class='navbar-brand' href='/'>Asset Availability Dashboard</a>";
  html += "    <button class='navbar-toggler' type='button' data-bs-toggle='collapse' data-bs-target='#navbarNav'><span class='navbar-toggler-icon'></span></button>";
  html += "    <div class='collapse navbar-collapse' id='navbarNav'>";
  html += "      <ul class='navbar-nav ms-auto'>";
  html += "        <li class='nav-item'><a class='nav-link active' href='/'>Dashboard</a></li>";
  html += "        <li class='nav-item'><a class='nav-link' href='/events'>Event Log</a></li>";
  html += "        <li class='nav-item'><a class='nav-link' href='/analytics-compare'>Compare Assets</a></li>";
  html += "        <li class='nav-item'><a class='nav-link' href='/config'>Setup</a></li>";
  html += "      </ul>";
  html += "    </div>";
  html += "  </div>";
  html += "</nav>";

  html += "<div class='container mt-4'>";
  // --- Placeholder for System Status Card (Original Style) ---
  html += "<div id='systemWideStatus'></div>";

  html += "<div class='card shadow-sm mb-4'>";
  html += "  <div class='card-header'><h4>Asset Overview</h4></div>";
  html += "  <div class='card-body'>";
  // --- Statrow for individual asset quick stats (Original Style) ---
  html += "    <div class='row g-2 mb-3' id='statrow'></div>";
  html += "    <div id='chart-container' style='min-height: 300px;'><canvas id='barChart'></canvas></div>";
  html += "  </div>";
  html += "</div>";

  html += "<div class='card shadow-sm'>";
  html += "  <div class='card-header'><h4>Live Status Details</h4></div>";
  html += "  <div class='card-body table-responsive'>";
  html += "    <table id='summaryTable' class='table table-striped table-hover table-sm align-middle'><thead><tr>";
  html += "      <th>Name</th><th>State</th><th>Avail (%)</th><th>Runtime</th><th>Downtime</th><th>MTBF</th><th>MTTR</th><th>Stops</th><th>Actions</th>";
  html += "    </tr></thead><tbody></tbody></table>";
  html += "  </div>";
  html += "</div>";
  html += "</div>";

  html += "<script>";
  html += R"rawliteral(
function formatHHMMSS(valInMinutes) {
  if (isNaN(valInMinutes) || valInMinutes < 0.01) return "00:00:00";
  let totalSeconds = Math.round(valInMinutes * 60);
  let h = Math.floor(totalSeconds / 3600);
  let m = Math.floor((totalSeconds % 3600) / 60);
  let s = totalSeconds % 60;
  return (h < 10 ? "0" : "") + h + ":" + (m < 10 ? "0" : "") + m + ":" + (s < 10 ? "0" : "") + s;
}
let chartObj=null;
function updateDashboard() {
  fetch('/api/summary').then(r=>r.json()).then(data=>{
    const systemStatusContainer = document.getElementById('systemWideStatus');
    let systemCardHtml = "";
    if (data.monitoringMode === 1 && data.systemStats) { // MONITORING_MODE_SERIAL is 1
        const isDown = data.systemStats.isDown;
        const systemStateClass = isDown ? "bg-danger text-white" : "bg-success text-white";
        const systemStatusText = isDown ? "SYSTEM DOWN" : "SYSTEM RUNNING";
        systemCardHtml = `
            <div class='card ${systemStateClass} shadow-sm mb-4'>
                <div class='card-body'>
                    <div class='d-flex justify-content-between align-items-center'>
                        <div>
                            <h5 class='card-title mb-1'>${systemStatusText}</h5>
                            ${isDown && data.systemStats.triggerAsset ? `<small>Triggered by: ${data.systemStats.triggerAsset}</small><br>` : ''}
                            <small>Availability: ${data.systemStats.availability.toFixed(2)}% | MTBF: ${formatHHMMSS(data.systemStats.mtbf_min)} | MTTR: ${formatHHMMSS(data.systemStats.mttr_min)}</small>
                        </div>
                        <div class='fs-1 fw-bold'>${data.systemStats.stopCount} <small class='fs-6 fw-normal'>Stops</small></div>
                    </div>
                </div>
            </div>`;
    }
    if (systemStatusContainer) { systemStatusContainer.innerHTML = systemCardHtml; }

    let tbody = document.querySelector('#summaryTable tbody');
    if (!tbody) return;
    tbody.innerHTML = ''; // Clear previous rows

    let statrow = document.getElementById('statrow');
    if(statrow) statrow.innerHTML = ''; // Clear previous stat cards

    let assets = data.assets;
    let n = assets.length;
    for(let i=0;i<n;++i){
      let asset = assets[i];
      let stateBadge = asset.state == 1 ? "<span class='badge bg-success'>RUNNING</span>" : "<span class='badge bg-danger'>STOPPED</span>";
      let assetNameEncoded = encodeURIComponent(asset.name);
      let newRow = tbody.insertRow();
      newRow.innerHTML = `
        <td><strong>${asset.name}</strong></td>
        <td>${stateBadge}</td>
        <td>${asset.availability.toFixed(2)}</td>
        <td>${formatHHMMSS(asset.total_runtime)}</td>
        <td>${formatHHMMSS(asset.total_downtime)}</td>
        <td>${formatHHMMSS(asset.mtbf)}</td>
        <td>${formatHHMMSS(asset.mttr)}</td>
        <td>${asset.stop_count}</td>
        <td><a href='/analytics?asset=${assetNameEncoded}' class='btn btn-sm btn-outline-primary py-0'>Analytics</a></td>
      `;

      // --- Reverted Statrow Cards ---
      if(statrow) {
        let statCardClass = asset.state == 1 ? "border-success bg-success-subtle" : "border-danger bg-danger-subtle";
        let statHtml = `
          <div class="col">
            <div class="card ${statCardClass} text-center h-100">
              <div class="card-header bg-transparent border-0 fw-bold">${asset.name}</div>
              <div class="card-body py-2">
                <h5 class="card-title mb-0">${asset.availability.toFixed(1)}%</h5>
                <small class="text-muted">Availability</small>
              </div>
              <div class="card-footer bg-transparent border-0 pt-0">
                 <small>${stateBadge} | Stops: ${asset.stop_count}</small>
              </div>
            </div>
          </div>`;
        statrow.innerHTML += statHtml;
      }
    }
    
    let availData=[], names=[], runtimeData=[], downtimeData=[];
    for (let asset of assets) {
      availData.push(asset.availability);
      runtimeData.push(asset.total_runtime);
      downtimeData.push(asset.total_downtime);
      names.push(asset.name);
    }
    
    // --- Reverted Bar Chart Datasets (Original Style) ---
    if (!window.chartObj) {
      const ctx = document.getElementById('barChart').getContext('2d');
      window.chartObj = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: names,
          datasets: [
            { label: 'Availability (%)', data: availData, backgroundColor: 'rgba(66, 165, 245, 0.7)', yAxisID: 'y' }, // #42a5f5
            { label: 'Runtime (min)', data: runtimeData, backgroundColor: 'rgba(102, 187, 106, 0.7)', yAxisID: 'y1' }, // #66bb6a
            { label: 'Downtime (min)', data: downtimeData, backgroundColor: 'rgba(239, 83, 80, 0.7)', yAxisID: 'y1' } // #ef5350
          ]
        },
        options: {
          responsive:true, maintainAspectRatio:false, indexAxis: 'x',
          scales: {
            y: { beginAtZero:true, max:100, title:{display:true,text:'Availability (%)'} },
            y1: { beginAtZero:true, position: 'right', grid: { drawOnChartArea: false }, title: { display:true, text:'Time (min)' }}
          },
          plugins: { legend: { display: true } }
        }
      });
    } else {
      window.chartObj.data.labels = names;
      window.chartObj.data.datasets[0].data = availData;
      window.chartObj.data.datasets[1].data = runtimeData;
      window.chartObj.data.datasets[2].data = downtimeData;
      window.chartObj.update();
    }
  }).catch(e => console.error("Dashboard update error:", e));
}
if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', updateDashboard); }
else { updateDashboard(); }
setInterval(updateDashboard, 5000);
)rawliteral";
  html += "</script>";
  html += "<script src='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js'></script>";
  html += "</body></html>";
  return html;
}

String htmlAnalytics() {
  String assetName = server.hasArg("asset") ? urlDecode(server.arg("asset")) : "";
  String html = "<!DOCTYPE html><html lang='en'><head><title>Analytics: ";
  html += assetName + "</title>";
  html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<link href='https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap' rel='stylesheet'>";
  html += "<link href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css' rel='stylesheet'>";
  html += "<script src='https://cdn.jsdelivr.net/npm/chart.js'></script>";
  html += "<style>body{background-color:#f8f9fa;}</style>";
  html += "</head><body>";

  // --- Standard Bootstrap Navbar ---
  html += "<nav class='navbar navbar-expand-lg navbar-dark bg-dark shadow-sm'>";
  html += "  <div class='container-fluid'>";
  html += "    <a class='navbar-brand' href='/'>Asset Availability</a>";
  html += "    <button class='navbar-toggler' type='button' data-bs-toggle='collapse' data-bs-target='#navbarNav'><span class='navbar-toggler-icon'></span></button>";
  html += "    <div class='collapse navbar-collapse' id='navbarNav'>";
  html += "      <ul class='navbar-nav ms-auto'>";
  html += "        <li class='nav-item'><a class='nav-link' href='/'>Dashboard</a></li>";
  html += "        <li class='nav-item'><a class='nav-link' href='/events'>Event Log</a></li>";
  html += "        <li class='nav-item'><a class='nav-link' href='/analytics-compare'>Compare Assets</a></li>";
  html += "        <li class='nav-item'><a class='nav-link' href='/config'>Setup</a></li>";
  html += "      </ul>";
  html += "    </div>";
  html += "  </div>";
  html += "</nav>";

  // --- Main Content Structure ---
  html += "<div class='container mt-4'>";
  html += "  <h2 class='mb-3'>Asset Analytics: <span id='assetNameInHeader'>" + assetName + "</span></h2>";
  // Placeholder for alerts (e.g., invalid date range)
  html += "  <div id='alertPlaceholder'></div>"; 
  html += "  <div class='row mb-4' id='kpiMetrics'></div>"; // KPI cards will be injected here by JS
  html += "  <div class='row g-4'>";
  html += "    <div class='col-lg-4'>"; // Controls column
  html += "      <div class='card h-100 shadow-sm'>";
  html += "        <div class='card-header'><h4>Controls</h4></div>";
  html += "        <div class='card-body'>";
  html += "          <div class='mb-3'><label for='fromTime' class='form-label'>From:</label><input type='datetime-local' id='fromTime' class='form-control'></div>";
  html += "          <div class='mb-3'><label for='toTime' class='form-label'>To:</label><input type='datetime-local' id='toTime' class='form-control'></div>";
  html += "          <div class='mb-2 form-check'><input type='checkbox' id='showStart' class='form-check-input' checked><label for='showStart' class='form-check-label'>Show START Events</label></div>";
  html += "          <div class='mb-2 form-check'><input type='checkbox' id='showStop' class='form-check-input' checked><label for='showStop' class='form-check-label'>Show STOP Events</label></div>";
  html += "          <div class='mb-2 form-check'><input type='checkbox' id='showMTBF' class='form-check-input'><label for='showMTBF' class='form-check-label'>Show MTBF Trend</label></div>";
  html += "          <div class='mb-3 form-check'><input type='checkbox' id='showMTTR' class='form-check-input'><label for='showMTTR' class='form-check-label'>Show MTTR Trend</label></div>";
  html += "          <button class='btn btn-secondary w-100' id='exportPng'>Export Chart as PNG</button>";
  html += "        </div>";
  html += "      </div>";
  html += "    </div>";
  html += "    <div class='col-lg-8'>"; // Chart column
  html += "      <div class='card h-100 shadow-sm'>";
  html += "        <div class='card-header'><h4 id='chartTitle'>Event History</h4></div>"; // Title will be updated by JS
  html += "        <div class='card-body'><canvas id='eventChart'></canvas></div>";
  html += "      </div>";
  html += "    </div>";
  html += "  </div>";
  html += "  <div class='card mt-4 shadow-sm'>"; // Recent Events Table
  html += "    <div class='card-header'><h4>Recent Events for this Asset (Unfiltered by Date Range)</h4></div>";
  html += "    <div class='card-body table-responsive'>";
  html += "      <table class='table table-sm table-striped table-hover'><thead><tr><th>Date</th><th>Time</th><th>Asset</th><th>Event</th><th>Avail(%)</th><th>Runtime</th><th>Downtime</th><th>MTBF</th><th>MTTR</th><th>Stops</th><th>Run Dur</th><th>Stop Dur</th><th>Note</th></tr></thead><tbody id='recentEvents'></tbody></table>";
  html += "    </div>";
  html += "  </div>";
  html += "</div>"; // End container

  // --- Start of JavaScript block ---
  html += "<script>";
  html += R"rawliteral(
// --- Constants for colors ---
const GREEN_COLOR = '#198754'; // Bootstrap Success
const RED_COLOR = '#dc3545';   // Bootstrap Danger
const AMBER_COLOR = '#ffc107'; // Bootstrap Warning
const INFO_COLOR = '#0dcaf0';  // Bootstrap Info

const alertPlaceholder = document.getElementById('alertPlaceholder'); // Get existing placeholder

const showAlert = (message, type) => {
  const wrapper = document.createElement('div');
  wrapper.innerHTML = `<div class="alert alert-${type} alert-dismissible" role="alert"><div>${message}</div><button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button></div>`;
  alertPlaceholder.innerHTML = ''; // Clear previous alerts
  alertPlaceholder.append(wrapper);
}

function floatMinToMMSS(val) {
  if (typeof val === "string") val = parseFloat(val);
  if (isNaN(val) || val < 0) return "00:00";
  let totalSeconds = Math.round(val * 60);
  if (totalSeconds >= 3600) { let h = Math.floor(totalSeconds / 3600); let m = Math.floor((totalSeconds % 3600) / 60); let s = totalSeconds % 60; return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; }
  else { let m = Math.floor(totalSeconds / 60); let s = totalSeconds % 60; return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; }
}

function renderKPIs(currentFilteredEventsArray, customMessage = null) {
  const kpiDiv = document.getElementById('kpiMetrics'); if (!kpiDiv) return;
  if (customMessage) { kpiDiv.innerHTML = `<div class='col-12'><div class='alert alert-warning'>${customMessage}</div></div>`; return; }
  if (!currentFilteredEventsArray || currentFilteredEventsArray.length === 0) { kpiDiv.innerHTML = "<div class='col-12'><div class='alert alert-info'>No specific START/STOP type events match the selected asset, date range, or display filters.</div></div>"; return; }
  try {
    const latestEvent = currentFilteredEventsArray[currentFilteredEventsArray.length - 1];
    const kpis = { "Stops": latestEvent[10], "Runtime": floatMinToMMSS(latestEvent[6]), "Downtime": floatMinToMMSS(latestEvent[7]), "Availability": `${parseFloat(latestEvent[5]).toFixed(2)}%`, "MTBF": floatMinToMMSS(latestEvent[8]), "MTTR": floatMinToMMSS(latestEvent[9]) };
    let kpiHtml = "";
    for (const [key, value] of Object.entries(kpis)) { kpiHtml += `<div class="col-lg-2 col-md-4 col-sm-6 col-6 mb-4"><div class="card text-center h-100 shadow-sm"><div class="card-header small">${key}</div><div class="card-body d-flex align-items-center justify-content-center p-2"><p class="card-text fs-5 fw-bold mb-0">${value || '-'}</p></div></div></div>`; }
    kpiDiv.innerHTML = kpiHtml;
  } catch (e) { console.error('Error rendering KPIs:', e); kpiDiv.innerHTML = "<div class='col-12'><div class='alert alert-danger'>Error rendering KPIs.</div></div>"; }
}

function mmssToSeconds(mmss) { if (!mmss || typeof mmss !== "string" || !mmss.includes(':')) return 0; let p = mmss.split(":"); if(p.length !== 2) return 0; let min = parseInt(p[0], 10); let sec = parseInt(p[1], 10); if(isNaN(min) || isNaN(sec)) return 0; return (min * 60) + sec; }
function parseEventDate(eventRow) { if (!eventRow || eventRow.length < 2) return new Date(0); try { let [d, m, y] = eventRow[0].split('/').map(Number); let [hh, mm, ss] = eventRow[1].split(':').map(Number); if (isNaN(d) || isNaN(m) || isNaN(y) || isNaN(hh) || isNaN(mm) || isNaN(ss)) return new Date(0); return new Date(Date.UTC(y, m - 1, d, hh, mm, ss)); } catch (e) { console.error('Error parsing date:', eventRow[0], eventRow[1], e); return new Date(0); } }
function toDatetimeLocal(dt) { if (!(dt instanceof Date) || isNaN(dt)) dt = new Date(); try { const tzo = dt.getTimezoneOffset() * 60000; const loc = new Date(dt.getTime() - tzo); return loc.toISOString().slice(0, 16); } catch (e) { const n = new Date(Date.now() - (new Date().getTimezoneOffset() * 60000)); return n.toISOString().slice(0, 16); } }
let asset = ''; let allEvents = []; let eventChart = null; let filteredEventsGlobal = []; let longStopThresholdSecs = 300; 
function normalizeAssetName(name) { return (name || '').toLowerCase().replace(/\s+/g, ''); }

function renderEventChart() {
  alertPlaceholder.innerHTML = ''; 
  let fromDateInput = document.getElementById('fromTime'); let toDateInput = document.getElementById('toTime');
  let fromDate, toDate;
  try {
    fromDate = new Date(fromDateInput.value); toDate = new Date(toDateInput.value);
    if (isNaN(fromDate.getTime()) || isNaN(toDate.getTime())) throw new Error("Invalid date format.");
  } catch (e) { showAlert("Error parsing date fields. Please ensure they are valid.", "danger"); if (eventChart) { eventChart.destroy(); eventChart = null; } renderKPIs(null, "Error in date fields."); document.getElementById('chartTitle').textContent = 'Event History'; return; }
  
  if (fromDate > toDate) {
    showAlert("Invalid Date Range: 'From' date cannot be after 'To' date. Please adjust the selection.", "danger");
    if (eventChart) { eventChart.destroy(); eventChart = null; } renderKPIs(null, "Invalid date range."); document.getElementById('chartTitle').textContent = 'Event History (Invalid Range)'; return;
  }

  const chartTitleEl = document.getElementById('chartTitle');
  const assetNameForTitle = asset || "Selected Asset";
  chartTitleEl.textContent = `Event History for ${assetNameForTitle} from ${fromDate.toLocaleDateString([], {day:'2-digit',month:'2-digit',year:'numeric'})} to ${toDate.toLocaleDateString([], {day:'2-digit',month:'2-digit',year:'numeric'})}`;

  if (!allEvents || allEvents.length === 0) { // This 'allEvents' is already asset-specific
    renderKPIs(null, `No events recorded for asset: ${assetNameForTitle}.`);
    if (eventChart) { eventChart.destroy(); eventChart = null; } return;
  }
  
  const showStart = document.getElementById('showStart').checked;
  const showStop = document.getElementById('showStop').checked;
  
  // Filter from allEvents (which is already asset-specific). SYS_ events are included if they match the asset.
  filteredEventsGlobal = allEvents.filter(e => {
    try {
      const eventDate = parseEventDate(e);
      if (eventDate < fromDate || eventDate > toDate) return false;
      
      const eventType = (e[3] || "").toUpperCase(); // Column 3 is eventType
      let isDisplayable = false;
      if (eventType.includes("START") && showStart) isDisplayable = true;
      if (eventType.includes("STOP") && showStop) isDisplayable = true;
      
      return isDisplayable;
    } catch { return false; }
  });

  renderKPIs(filteredEventsGlobal); 
  
  if (filteredEventsGlobal.length === 0) {
    if (eventChart) { eventChart.destroy(); eventChart = null; }
    return; 
  }

  try {
    let stateArr = filteredEventsGlobal.map(e => e[4] ? e[4].trim() : '0'); // Column 4 is state
    
    let datasets = [{
        label: 'Asset State (Availability %)', data: filteredEventsGlobal.map(e => parseFloat(e[5])), // Column 5 is Availability
        yAxisID: 'y',
        stepped: true,
        pointRadius: 5,
        pointBackgroundColor: filteredEventsGlobal.map(e => (e[4] === '1' ? GREEN_COLOR : RED_COLOR)), // Green for state 1 (START/SYS_START), Red for state 0 (STOP/SYS_STOP)
        segment: { 
            borderColor: ctx => (stateArr[ctx.p0DataIndex] === "1" ? GREEN_COLOR : RED_COLOR), 
            borderWidth: 3 
        }
    }];

    if (document.getElementById('showMTBF').checked) datasets.push({ label: 'MTBF (min)', data: filteredEventsGlobal.map(e => parseFloat(e[8])), yAxisID: 'y1', borderColor: INFO_COLOR, borderWidth: 2, tension: 0.1, pointRadius: 3, pointStyle: 'rect' });
    if (document.getElementById('showMTTR').checked) datasets.push({ label: 'MTTR (min)', data: filteredEventsGlobal.map(e => parseFloat(e[9])), yAxisID: 'y1', borderColor: AMBER_COLOR, borderWidth: 2, tension: 0.1, pointRadius: 3, pointStyle: 'triangle' });
    
    if (eventChart) eventChart.destroy();
    eventChart = new Chart(document.getElementById('eventChart').getContext('2d'), {
      type: 'line',
      data: { labels: filteredEventsGlobal.map(e => e[1]), datasets: datasets }, // Column 1 is Time
      options: { 
          responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, 
          layout: { padding: { top: 15 }},
          plugins: { 
            tooltip: { 
              callbacks: { 
                title: (tooltipItems) => { if (!tooltipItems.length) return ''; const idx = tooltipItems[0].dataIndex; if (!filteredEventsGlobal[idx]) return 'Error'; return `Event: ${filteredEventsGlobal[idx][3]} at ${filteredEventsGlobal[idx][0]} ${filteredEventsGlobal[idx][1]}`; }, 
                label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.y !== null) { if (context.dataset.label === 'Asset State (Availability %)') { label += parseFloat(context.parsed.y).toFixed(2) + '%'; } else { label += floatMinToMMSS(context.parsed.y); } } return label; }
              } 
            },
            legend: { position: 'top' }
          },
          scales: { 
            x: { title: { display: true, text: 'Time' } }, 
            y: { title: { display: true, text: 'Availability (%)' }, beginAtZero: true, suggestedMax: 100, ticks: { stepSize: 20, callback: function(v){ if(v > 100 || v < 0) return; if(v % 20 === 0) return v;}}}, 
            y1: { type: 'linear', display: true, position: 'right', title: { display: true, text: 'MTBF/MTTR (min)' }, beginAtZero: true, grid: { drawOnChartArea: false }, ticks: { callback: val => floatMinToMMSS(val) } } 
          }
      }
    });
  } catch (e) { console.error('Error rendering chart:', e); showAlert('Error displaying chart.', 'danger'); }
}

function fetchAnalyticsData() {
  try { asset = decodeURIComponent(new URLSearchParams(window.location.search).get("asset") || ""); } catch(e) {console.error("Error decoding asset from URL", e);}
  const assetNameElement = document.getElementById('assetNameInHeader');
  if (assetNameElement) assetNameElement.textContent = asset;
  
  if (!asset) { renderKPIs(null, "No asset specified. Please select an asset from the dashboard."); if (eventChart) { eventChart.destroy(); eventChart = null; } document.getElementById('chartTitle').textContent = 'Event History'; return; }

  Promise.all([
      fetch('/api/events').then(r => { if(!r.ok) throw new Error(`API Events: ${r.status}`); return r.json(); }),
      fetch('/api/config').then(r => { if(!r.ok) throw new Error(`API Config: ${r.status}`); return r.json(); })
  ]).then(([rawEvents, config]) => {
      longStopThresholdSecs = config.longStopThresholdSec || 300;
      // Initial filter for the specific asset - this populates 'allEvents'
      // It will include START, STOP, SYS_START, SYS_STOP where column 2 matches the asset name.
      allEvents = Array.isArray(rawEvents) ? rawEvents.filter(e => e.length > 13 && e[2] && normalizeAssetName(e[2]) === normalizeAssetName(asset)) : [];
      
      if (allEvents.length === 0) { // No events AT ALL for this asset in the log
        renderKPIs(null, `No events found for asset: ${asset}.`);
        if (eventChart) { eventChart.destroy(); eventChart = null; }
        document.getElementById('chartTitle').textContent = `Event History for ${asset}`;
      }
      setupRangePickers(); // Sets default dates based on allEvents
      renderEventChart();  // Applies date filters and renders
      renderRecentEvents(); 
  }).catch(e => { console.error("Fetch error for analytics:", e); showAlert(`Data Load Failed: ${e.message}`, 'danger'); renderKPIs(null, "Data load failed."); if (eventChart) { eventChart.destroy(); eventChart = null; } document.getElementById('chartTitle').textContent = 'Event History'; });
}

function setupRangePickers() { 
  let defaultFromDate, defaultToDate;
  if (allEvents.length > 0) {
    try {
      let eventDates = allEvents.map(e => parseEventDate(e)).filter(d => d.getTime() !== 0);
      if (eventDates.length > 0) {
        defaultToDate = new Date(Math.max.apply(null, eventDates));
        defaultFromDate = new Date(defaultToDate.getTime() - (12 * 60 * 60 * 1000)); 
      } else { defaultToDate = new Date(); defaultFromDate = new Date(defaultToDate.getTime() - (12 * 60 * 60 * 1000)); }
    } catch (e) { defaultToDate = new Date(); defaultFromDate = new Date(defaultToDate.getTime() - (12 * 60 * 60 * 1000)); }
  } else { defaultToDate = new Date(); defaultFromDate = new Date(defaultToDate.getTime() - (12 * 60 * 60 * 1000)); }
  document.getElementById('fromTime').value = toDatetimeLocal(defaultFromDate);
  document.getElementById('toTime').value = toDatetimeLocal(defaultToDate);
  ['fromTime', 'toTime', 'showStart', 'showStop', 'showMTBF', 'showMTTR'].forEach(id => { const el = document.getElementById(id); if (el) el.onchange = renderEventChart; });
  const exportButton = document.getElementById('exportPng');
  if (exportButton) { exportButton.onclick = function () { if (!eventChart || !filteredEventsGlobal || filteredEventsGlobal.length === 0) return showAlert("Cannot export empty or invalid chart.", "warning"); try { let url = eventChart.toBase64Image(); let a = document.createElement('a'); a.href = url; a.download = `analytics_${asset || 'chart'}.png`; a.click(); } catch (e) { console.error('Error exporting chart:', e), showAlert("Error exporting chart.", "danger"); } }; }
}

function renderRecentEvents() { 
  // This table shows the last 10 events from 'allEvents' (already asset-specific), unfiltered by date pickers.
  const tbody = document.getElementById('recentEvents'); if (!tbody) return; tbody.innerHTML = "";
  if (!allEvents || allEvents.length === 0) { tbody.innerHTML = `<tr><td colspan='13' class='text-center'>No events recorded for asset: ${asset||"Unknown"}.</td></tr>`; return; }
  const eventsToDisplay = allEvents.slice(-10).reverse(); 
  if (eventsToDisplay.length === 0) { tbody.innerHTML = `<tr><td colspan='13' class='text-center'>No recent events for ${asset||"Unknown"}.</td></tr>`; return; }
  eventsToDisplay.forEach(eventRow => {
    try {
      if (!Array.isArray(eventRow) || eventRow.length < 14) { let tr = tbody.insertRow(), td = tr.insertCell(); td.colSpan = 13; td.textContent = "Malformed event data."; td.style.color = "orange"; return; }
      let [date, time, assetName, eventType, state, avail, runtime, downtime, mtbf, mttr, stops, runDur, stopDur, note] = eventRow;
      let tr = tbody.insertRow();
      tr.insertCell().textContent = date; tr.insertCell().textContent = time; tr.insertCell().textContent = assetName; tr.insertCell().textContent = eventType;
      tr.insertCell().textContent = parseFloat(avail).toFixed(2); tr.insertCell().textContent = floatMinToMMSS(runtime); tr.insertCell().textContent = floatMinToMMSS(downtime);
      tr.insertCell().textContent = floatMinToMMSS(mtbf); tr.insertCell().textContent = floatMinToMMSS(mttr); tr.insertCell().textContent = stops;
      tr.insertCell().textContent = runDur && runDur.includes(':') ? runDur : "00:00"; // Check if it's already formatted
      tr.insertCell().textContent = stopDur && stopDur.includes(':') ? stopDur : "00:00";
      tr.insertCell().textContent = note || "";
    } catch (e) { console.error('Error rendering recent event row:', eventRow, e); let tr = tbody.insertRow(), td = tr.insertCell(); td.colSpan = 13; td.textContent = "Error displaying row."; td.style.color = "red"; }
  });
}
document.addEventListener('DOMContentLoaded', fetchAnalyticsData);
)rawliteral";
  html += "</script>";
  html += "<script src='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js'></script>";
  html += "</body></html>";
  return html;
}

String htmlAnalyticsCompare() {
  String html = "<!DOCTYPE html><html lang='en'><head><title>Compare Assets</title>";
  html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<link href='https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap' rel='stylesheet'>";
  html += "<link href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css' rel='stylesheet'>";
  html += "<script src='https://cdn.jsdelivr.net/npm/chart.js'></script>";
  html += "<style>body{background-color:#f8f9fa;}</style>";
  html += "</head><body>";

  html += "<nav class='navbar navbar-expand-lg navbar-dark bg-dark shadow-sm'>";
  html += "  <div class='container-fluid'>";
  html += "    <a class='navbar-brand' href='/'>Asset Availability</a>";
  html += "    <button class='navbar-toggler' type='button' data-bs-toggle='collapse' data-bs-target='#navbarNav'><span class='navbar-toggler-icon'></span></button>";
  html += "    <div class='collapse navbar-collapse' id='navbarNav'>";
  html += "      <ul class='navbar-nav ms-auto'>";
  html += "        <li class='nav-item'><a class='nav-link' href='/'>Dashboard</a></li>";
  html += "        <li class='nav-item'><a class='nav-link' href='/events'>Event Log</a></li>";
  html += "        <li class='nav-item'><a class='nav-link active' href='/analytics-compare'>Compare Assets</a></li>";
  html += "        <li class='nav-item'><a class='nav-link' href='/config'>Setup</a></li>";
  html += "      </ul>";
  html += "    </div>";
  html += "  </div>";
  html += "</nav>";

  html += "<div class='container mt-4'>";
  html += "  <div class='row'>";
  html += "    <div class='col-lg-6 mb-4'><div class='card shadow-sm'><div class='card-body'><canvas id='barAvail'></canvas></div></div></div>";
  html += "    <div class='col-lg-6 mb-4'><div class='card shadow-sm'><div class='card-body'><canvas id='barStops'></canvas></div></div></div>";
  html += "    <div class='col-lg-6 mb-4'><div class='card shadow-sm'><div class='card-body'><canvas id='barMTBF'></canvas></div></div></div>";
  html += "    <div class='col-lg-6 mb-4'><div class='card shadow-sm'><div class='card-body'><canvas id='pieReasons'></canvas></div></div></div>";
  html += "  </div>";
  html += "  <div class='card mt-3 shadow-sm'><div class='card-header'><h4>Last Event Log Summary</h4></div><div class='card-body table-responsive'>";
  html += "    <table class='table table-striped table-hover'><thead><tr><th>Asset</th><th>Availability (%)</th><th>Runtime</th><th>Downtime</th><th>Stops</th><th>MTBF</th><th>MTTR</th></tr></thead><tbody id='compareTable'></tbody></table>";
  html += "  </div></div>";
  html += "</div>";

  html += "<script>";
  html += R"rawliteral(
let allEventsCompare = [], allAssetNamesCompare = [], configDowntimeReasonsCompare = [];
function formatMinutesToHHMMSSCompare(val) { if (isNaN(val) || val <= 0.001) return "0:00:00"; let t = Math.round(60 * val), n = Math.floor(t / 3600), a = Math.floor(t % 3600 / 60); return t %= 60, `${n}:${a.toString().padStart(2,"0")}:${(t).toString().padStart(2,"0")}` }
function fetchCompareDataPage() { fetch("/api/config").then(e => e.json()).then(e => { configDowntimeReasonsCompare = e.downtimeReasons || [], allAssetNamesCompare = e.assets.map(e => e.name), fetch("/api/events").then(e => e.json()).then(t => { allEventsCompare = t.map(e => Array.isArray(e) ? e : []).filter(e => e.length > 13 && allAssetNamesCompare.includes(e[2])), renderCompareChartsPage(), renderCompareTablePage() }).catch(e => console.error("CompareEventsFetchErr:", e)) }).catch(e => console.error("CompareConfigFetchErr:", e)) }
function getLastMetricCompare(e, t) { return e && e.length ? parseFloat(e[e.length - 1][t]) : 0 }

function renderCompareChartsPage() {
  const GREEN = 'rgba(25, 135, 84, 0.8)', AMBER = 'rgba(255, 193, 7, 0.8)', RED = 'rgba(220, 53, 69, 0.8)';
  let byAsset = {}; allAssetNamesCompare.forEach(e => { byAsset[e] = [] });
  for (let e of allEventsCompare) byAsset[e[2]] && byAsset[e[2]].push(e);
  let labels = allAssetNamesCompare;
  let avail = labels.map(e => getLastMetricCompare(byAsset[e] || [], 5));
  let stops = labels.map(e => (byAsset[e] || []).filter(e => "STOP" === (e[3] || "").toUpperCase()).length);
  let mtbf = labels.map(e => getLastMetricCompare(byAsset[e] || [], 8));
  let reasons = {}; configDowntimeReasonsCompare.forEach(e => { e && (reasons[e] = 0) });
  for (let e of allEventsCompare) { if (!(e.length < 14)) { let t = e[13] || "", n = ""; n = t.includes(" - ") ? t.split(" - ")[0].trim() : t.trim(), n && reasons.hasOwnProperty(n) && reasons[n]++ } }
  const pieLabels = Object.keys(reasons).filter(e => reasons[e] > 0);
  const pieData = pieLabels.map(e => reasons[e]);
  const pieColors = ["#ffc107", "#fd7e14", "#dc3545", "#d63384", "#6f42c1", "#20c997", "#0dcaf0"];
  const availColors = avail.map(e => e >= 90 ? GREEN : e >= 75 ? AMBER : RED); // Dynamic colors for Availability

  ["barAvail", "barStops", "barMTBF", "pieReasons"].forEach(e => { const t = document.getElementById(e); t && t.chartInstance && t.chartInstance.destroy() });
  const chartOptions = e => ({ plugins: { title: { display: !0, text: e, font: { size: 16 } } }, scales: { y: { beginAtZero: !0 } }, responsive: !0, maintainAspectRatio: !0 });
  const pieOptions = { plugins: { title: { display: !0, text: "Downtime Reason Distribution", font: { size: 16 } } }, responsive: !0, maintainAspectRatio: !0 };
  
  if (document.getElementById("barAvail")) { document.getElementById("barAvail").chartInstance = new Chart(document.getElementById("barAvail").getContext("2d"), { type: "bar", data: { labels: labels, datasets: [{ label: "Availability (%)", data: avail, backgroundColor: availColors }] }, options: chartOptions("Availability by Asset (%)") }) }
  if (document.getElementById("barStops")) { document.getElementById("barStops").chartInstance = new Chart(document.getElementById("barStops").getContext("2d"), { type: "bar", data: { labels: labels, datasets: [{ label: "Total Stops", data: stops, backgroundColor: AMBER }] }, options: chartOptions("Total Stops by Asset") }) }
  if (document.getElementById("barMTBF")) { document.getElementById("barMTBF").chartInstance = new Chart(document.getElementById("barMTBF").getContext("2d"), { type: "bar", data: { labels: labels, datasets: [{ label: "MTBF (min)", data: mtbf, backgroundColor: GREEN }] }, options: chartOptions("MTBF by Asset (minutes)") }) }
  const pc = document.getElementById("pieReasons");
  if (pc) {
    if (pieLabels.length > 0) { pc.chartInstance = new Chart(pc.getContext("2d"), { type: "pie", data: { labels: pieLabels, datasets: [{ data: pieData, backgroundColor: pieColors.slice(0, pieLabels.length) }] }, options: pieOptions }) }
    else { let e = pc.getContext("2d"); e.clearRect(0, 0, pc.width, pc.height), e.textAlign = "center", e.fillText("No reason data.", pc.width / 2, pc.height / 2) }
  }
}

function renderCompareTablePage() { let e = document.getElementById("compareTable"); if (!e) return; e.innerHTML = ""; let t = {}; allAssetNamesCompare.forEach(e => { t[e] = [] }); for (let n of allEventsCompare) t[n[2]] && t[n[2]].push(n); for (let n of allAssetNamesCompare) { let a = t[n] || [], l = a.length ? a[a.length - 1] : null; e.innerHTML += `<tr><td>${n}</td><td>${l&&l[5]?parseFloat(l[5]).toFixed(2):"-"}</td><td>${l&&l[6]?formatMinutesToHHMMSSCompare(parseFloat(l[6])):"-"}</td><td>${l&&l[7]?formatMinutesToHHMMSSCompare(parseFloat(l[7])):"-"}</td><td>${l&&l[10]?l[10]:"-"}</td><td>${l&&l[8]?formatMinutesToHHMMSSCompare(parseFloat(l[8])):"-"}</td><td>${l&&l[9]?formatMinutesToHHMMSSCompare(parseFloat(l[9])):"-"}</td></tr>` } }
document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", fetchCompareDataPage) : fetchCompareDataPage();
)rawliteral";
  html += "</script>";
  html += "<script src='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js'></script>";
  html += "</body></html>";
  return html;
}

void sendHtmlEventsPage() {
  server.setContentLength(CONTENT_LENGTH_UNKNOWN);
  server.send(200, "text/html", "");

  server.sendContent("<!DOCTYPE html><html lang='en'><head><title>Event Log</title>");
  server.sendContent("<meta name='viewport' content='width=device-width,initial-scale=1'>");
  server.sendContent("<link href='https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap' rel='stylesheet'>");
  server.sendContent("<link href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css' rel='stylesheet'>");
  server.sendContent("<style>body{background-color:#f8f9fa;}.note{font-style:italic;color:#555;}");
  server.sendContent("@media (max-width:700px){.eventCard{background:#fff;border-radius:.375rem;box-shadow:0 .125rem .25rem rgba(0,0,0,.075);margin-bottom:1rem;padding:1rem;}.eventCard div{margin-bottom:0.3em;}#eventTable{display:none;}}");
  server.sendContent("@media (min-width:701px){#mobileEvents{display:none;}}</style></head>");
  
  server.sendContent("<body>");
  String navHtml = "<nav class='navbar navbar-expand-lg navbar-dark bg-dark shadow-sm'>"
                   "<div class='container-fluid'>"
                   "<a class='navbar-brand' href='/'>Asset Availability</a>"
                   "<button class='navbar-toggler' type='button' data-bs-toggle='collapse' data-bs-target='#navbarNav'><span class='navbar-toggler-icon'></span></button>"
                   "<div class='collapse navbar-collapse' id='navbarNav'>"
                   "<ul class='navbar-nav ms-auto'>"
                   "<li class='nav-item'><a class='nav-link' href='/'>Dashboard</a></li>"
                   "<li class='nav-item'><a class='nav-link active' href='/events'>Event Log</a></li>"
                   "<li class='nav-item'><a class='nav-link' href='/analytics-compare'>Compare Assets</a></li>"
                   "<li class='nav-item'><a class='nav-link' href='/config'>Setup</a></li>"
                   "</ul></div></div></nav>";
  server.sendContent(navHtml);

  server.sendContent("<div class='container mt-4'><div class='card shadow-sm'><div class='card-body'>");
  
  String filterRowHtml = "<div class='row g-3 align-items-end mb-3'>"
                         "<div class='col-md-3'><label for='channelFilter' class='form-label'>Filter by Asset:</label><select id='channelFilter' class='form-select'><option value='ALL' selected>All Assets</option></select></div>" // Added selected
                         "<div class='col-md-3'><label for='stateFilter' class='form-label'>Event State:</label><select id='stateFilter' class='form-select'><option value='ALL'>All</option><option value='RUNNING'>Running</option><option value='STOPPED'>Stopped</option></select></div>"
                         "<div class='col-md-2'><button class='btn btn-secondary w-100' id='scrollBtn' type='button' onclick='toggleScrollInhibit(this)'>Pause Scroll</button></div>"
                         "<div class='col-md-2'><a href='/export_log' class='btn btn-info w-100'>Export CSV</a></div>"
                         "<div class='col-md-2'><div id='eventCount' class='text-muted text-end pt-2'></div></div>" // pt-2 for alignment
                         "</div>";
  server.sendContent(filterRowHtml);
  
  String tableHtml = "<div class='table-responsive'><table id='eventTable' class='table table-sm table-striped table-hover align-middle'><thead><tr>"
                     "<th>Date</th><th>Time</th><th>Asset</th><th>Event</th><th>State</th><th>Avail(%)</th><th>Runtime</th><th>Downtime</th><th>MTBF</th><th>MTTR</th><th>Stops</th><th>Run Dur</th><th>Stop Dur</th><th>Note</th>"
                     "</tr></thead><tbody id='tbody'></tbody></table></div>"
                     "<div id='mobileEvents'></div>";
  server.sendContent(tableHtml);
  server.sendContent("</div></div></div>");

  String modalHtml = "<div class='modal fade' id='noteEditModal' tabindex='-1' aria-labelledby='noteModalLabel' aria-hidden='true'>"
                     "<div class='modal-dialog'><div class='modal-content'>"
                     "<div class='modal-header'><h5 class='modal-title' id='noteModalLabel'>Edit Event Note</h5><button type='button' class='btn-close' data-bs-dismiss='modal' aria-label='Close'></button></div>"
                     "<form id='modalNoteForm' onsubmit='return submitModalNote(event)'><div class='modal-body'>"
                     "<input type='hidden' id='modalNoteDate' name='date'><input type='hidden' id='modalNoteTime' name='time'><input type='hidden' id='modalNoteAsset' name='asset'>"
                     "<div class='mb-3'><label for='modalNoteReason' class='form-label'>Reason:</label><select id='modalNoteReason' name='reason' class='form-select'></select></div>" // Will be populated by JS
                     "<div class='mb-3'><label for='modalNoteText' class='form-label'>Note:</label><input type='text' id='modalNoteText' name='note' class='form-control' maxlength='64' placeholder='Add/Edit note'></div>"
                     "</div><div class='modal-footer'>"
                     "<button type='button' class='btn btn-secondary' data-bs-dismiss='modal'>Cancel</button>"
                     "<button type='submit' class='btn btn-primary'>Save Note</button>"
                     "</div></form></div></div></div>";
  server.sendContent(modalHtml);

  server.sendContent("<script src='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js'></script>");
  server.sendContent("<script>");
  server.sendContent(R"rawliteral(
let eventData = [];
let channelList = []; // Will be populated by fetchChannelsAndStart
let filterValue = "ALL";
let stateFilter = "ALL";
window.downtimeReasons = []; // Will be populated by fetchReasonsAndEvents
let scrollInhibit = false;
let refreshIntervalId = null;
let noteModal = null; // Bootstrap Modal instance

function startAutoRefresh() {
  if (refreshIntervalId) clearInterval(refreshIntervalId);
  refreshIntervalId = setInterval(fetchAndRenderEvents, 5000);
}
function stopAutoRefresh() {
  if (refreshIntervalId) clearInterval(refreshIntervalId);
  refreshIntervalId = null;
}

function initializeEventPage() {
  noteModal = new bootstrap.Modal(document.getElementById('noteEditModal'));
  fetchChannelsAndStart(); // This will also trigger fetching reasons and then events
}

function fetchChannelsAndStart() {
  fetch('/api/summary')
    .then(r => {
      if (!r.ok) throw new Error(`API Summary Error: ${r.status}`);
      return r.json();
    })
    .then(data => {
      channelList = []; // Reset channel list
      if (data && data.assets && Array.isArray(data.assets)) {
        channelList = data.assets.map(a => a.name).filter(name => name && name.trim() !== "");
      } else {
        console.error("CRIT: 'data.assets' is not a valid array in API summary response.", data);
      }
      
      let sel = document.getElementById('channelFilter');
      if (!sel) { console.error("CRIT: 'channelFilter' select element not found."); return; }
      
      // Clear existing options except the "All Assets" and "SYSTEM"
      sel.innerHTML = "<option value='ALL' selected>All Assets</option>";
      sel.innerHTML += "<option value='SYSTEM_EVENTS_ONLY'>SYSTEM Events Only</option>";
      
      channelList.forEach(c => {
        let o = document.createElement("option");
        o.value = c; o.text = c;
        sel.appendChild(o);
      });
      sel.onchange = function() { filterValue = this.value; renderTable(); };
      
      let stateSel = document.getElementById('stateFilter');
      if (!stateSel) { console.error("CRIT: 'stateFilter' select element not found."); return; }
      stateSel.onchange = function() { stateFilter = this.value; renderTable(); };
      
      fetchReasonsAndEvents(); // Fetch reasons, then events
    })
    .catch(e => {
      console.error("Error fetching channels/summary for filters:", e);
      const mainCard = document.querySelector(".card-body");
      if(mainCard) mainCard.innerHTML = "<p class='alert alert-danger'>Error loading filter data. Check console.</p>";
    });
}

function fetchReasonsAndEvents() {
  fetch('/api/config')
    .then(r => {
      if (!r.ok) throw new Error(`API Config Error: ${r.status}`);
      return r.json();
    })
    .then(cfg => {
      window.downtimeReasons = (cfg && cfg.downtimeReasons) || [];
      fetchAndRenderEvents(); // Now fetch events
      startAutoRefresh();
    })
    .catch(e => {
      console.error("Error fetching config reasons:", e);
      // Optionally, inform user or proceed without reasons
      fetchAndRenderEvents(); // Still try to fetch events
      startAutoRefresh();
    });
}

function fetchAndRenderEvents() {
  fetch('/api/events')
    .then(r => {
      if (!r.ok) throw new Error(`API Events Error: ${r.status}`);
      return r.json();
    })
    .then(events => {
      if (Array.isArray(events)) {
        eventData = events;
      } else {
        console.error("Fetched event data is not an array:", events);
        eventData = []; // Default to empty array on error
      }
      renderTable();
    })
    .catch(e => {
      console.error("Error fetching events:", e);
      eventData = []; // Default to empty on error
      renderTable(); // Attempt to render (will show "no data")
      const tb = document.getElementById('tbody');
      if(tb) tb.innerHTML = "<tr><td colspan='14' class='text-center text-danger'>Failed to load events. Check console.</td></tr>";
      const md = document.getElementById('mobileEvents');
      if(md) md.innerHTML = "<p class='alert alert-danger text-center'>Failed to load events. Check console.</p>";
    });
}

function populateModalReasons() {
  const reasonSelect = document.getElementById('modalNoteReason');
  if (!reasonSelect) return;
  reasonSelect.innerHTML = '<option value=""></option>'; // Default empty
  (window.downtimeReasons || []).forEach(r => {
    if (r && r.trim() !== "") { // Ensure reason is not empty
      let opt = document.createElement('option');
      opt.value = r; opt.text = r;
      reasonSelect.appendChild(opt);
    }
  });
  let otherOpt = document.createElement('option');
  otherOpt.value = "Other"; otherOpt.text = "Other (Specify Below)";
  reasonSelect.appendChild(otherOpt);
}

function showNoteModal(date, time, asset, currentFullNote) {
  stopAutoRefresh();
  populateModalReasons();
  document.getElementById('modalNoteDate').value = date;
  document.getElementById('modalNoteTime').value = time;
  document.getElementById('modalNoteAsset').value = asset;
  let currentReason = "";
  let currentTextNote = currentFullNote || "";
  if (currentFullNote) {
    if ((window.downtimeReasons || []).includes(currentFullNote)) {
      currentReason = currentFullNote; currentTextNote = "";
    } else {
      for (const reason of (window.downtimeReasons || [])) {
        if (reason && currentFullNote.startsWith(reason + " - ")) {
          currentReason = reason; currentTextNote = currentFullNote.substring(reason.length + 3); break;
        }
      }
    }
  }
  const reasonDropdown = document.getElementById('modalNoteReason');
  if (reasonDropdown) reasonDropdown.value = currentReason;
  document.getElementById('modalNoteText').value = currentTextNote;
  noteModal.show();
}

document.getElementById('noteEditModal').addEventListener('hidden.bs.modal', event => {
  startAutoRefresh();
});

function submitModalNote(event) {
  event.preventDefault();
  const form = document.getElementById('modalNoteForm');
  const params = new URLSearchParams();
  params.append('date', form.date.value);
  params.append('time', form.time.value);
  params.append('asset', form.asset.value);
  params.append('reason', form.reason.value);
  params.append('note', form.note.value);
  fetch('/api/note', { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: params.toString() })
    .then(r => { if (r.ok) { fetchAndRenderEvents(); } else { alert("Failed to save note. Status: " + r.status); }})
    .catch(err => { console.error("Error saving note:", err); alert("Error saving note."); });
  noteModal.hide();
  return false;
}

function cleanNote(val) { if (!val) return ""; let v = val.trim(); return (v === "" || v === "," || v === ",,") ? "" : v.replace(/^,+|,+$/g, ""); }
function minToHHMMSS(valStr) { let val = parseFloat(valStr); if (isNaN(val) || val <= 0.001) return "00:00:00"; let s_total = Math.round(val * 60); let h=Math.floor(s_total/3600), m=Math.floor((s_total%3600)/60), s=s_total%60; return `${h<10?"0":""}${h}:${m<10?"0":""}${m}:${s<10?"0":""}${s}`; }
function durationStrToHHMMSS(str) { if (!str || typeof str !== "string" || str.trim()==="") return ""; let p=str.split(":").map(Number); let h=0,m=0,s=0; if(p.length===2){[m,s]=p;h=Math.floor(m/60);m%=60;} else if(p.length===3){[h,m,s]=p;} else return ""; if(isNaN(h)||isNaN(m)||isNaN(s))return ""; return `${h>0?(h<10?"0":"")+h+":":""}${m<10?"0":"0"}${m}:${s<10?"0":"0"}${s}`; }
function normalizeAssetName(name) { return (name || '').toLowerCase().replace(/\s+/g, ''); }

function renderTable() {
    let tbody = document.getElementById('tbody');
    let mobileDiv = document.getElementById('mobileEvents');
    if (!tbody || !mobileDiv) { console.error("Table/mobile div not found in renderTable"); return; }
    tbody.innerHTML = ''; mobileDiv.innerHTML = '';
    
    let displayedCount = 0;
    if (!eventData || !Array.isArray(eventData)) {
        console.warn("eventData is not an array or is null in renderTable.");
        eventData = []; // Ensure it's an array to prevent errors
    }

    let stateMatcher = (sVal) => (stateFilter === "ALL") || (stateFilter === "RUNNING" && sVal === "1") || (stateFilter === "STOPPED" && sVal === "0");
    let isMobile = window.innerWidth <= 700;
    
    // Iterate in reverse to show newest first, but build the array first then reverse.
    // Or, if your server sends them newest first, iterate normally.
    // Assuming server sends oldest first, so we reverse for display.
    const eventsToRender = eventData.slice().reverse();

    for (let i = 0; i < eventsToRender.length; ++i) {
        let vals = eventsToRender[i];
        if (!Array.isArray(vals) || vals.length < 13) { // Check for at least 13 elements
            console.warn("Skipping malformed event row:", vals);
            continue;
        }

        let [ldate, ltime, lasset, levent, lstateVal, lavail, lrun, lstop, lmtbf, lmttr, lsc, runDurStr, stopDurStr] = vals;
        let lnote = vals.length > 13 ? vals.slice(13).join(',').replace(/\n$/, "").trim() : ""; // Get full note

        let stopsInt = Math.round(Number(lsc));
        let isSystemEvent = (levent === "SYS_START" || levent === "SYS_STOP");

        if (filterValue === "SYSTEM_EVENTS_ONLY" && !isSystemEvent) continue;
        if (filterValue !== "ALL" && filterValue !== "SYSTEM_EVENTS_ONLY" && normalizeAssetName(lasset) !== normalizeAssetName(filterValue)) continue;
        if (!isSystemEvent && !stateMatcher(lstateVal)) continue;
        
        displayedCount++;
        let escapedNote = cleanNote(lnote).replace(/"/g, "&quot;").replace(/'/g, "\\'");

        if (!isMobile) {
            let tr = document.createElement('tr');
            if (isSystemEvent) tr.style.backgroundColor = "#e3f2fd"; // Light blue for system events
            function td(txt) { let e = document.createElement('td'); e.innerHTML = txt; return e; }
            tr.appendChild(td(ldate)); tr.appendChild(td(ltime)); tr.appendChild(td(lasset)); tr.appendChild(td(levent));
            let stateDisplay = lstateVal == "1" ? "<span class='badge bg-success'>RUNNING</span>" : "<span class='badge bg-danger'>STOPPED</span>";
            if (isSystemEvent) stateDisplay = lstateVal == "1" ? "<span class='badge bg-info text-dark'>SYSTEM UP</span>" : "<span class='badge bg-warning text-dark'>SYSTEM DOWN</span>";
            tr.appendChild(td(stateDisplay));
            tr.appendChild(td(Number(lavail).toFixed(2))); tr.appendChild(td(minToHHMMSS(lrun))); tr.appendChild(td(minToHHMMSS(lstop)));
            tr.appendChild(td(minToHHMMSS(lmtbf))); tr.appendChild(td(minToHHMMSS(lmttr))); tr.appendChild(td(String(stopsInt)));
            tr.appendChild(td(isSystemEvent ? "" : (levent.toUpperCase() === "STOP" ? durationStrToHHMMSS(runDurStr) : "")));
            tr.appendChild(td(isSystemEvent ? "" : (levent.toUpperCase() === "START" ? durationStrToHHMMSS(stopDurStr) : "")));
            let tdNote = document.createElement('td');
            tdNote.innerHTML = `<span class='note'>${cleanNote(lnote)}</span> <button class='btn btn-sm btn-outline-primary py-0 px-1' onclick='showNoteModal("${ldate}","${ltime}","${lasset}","${escapedNote}")'>Edit</button>`;
            tr.appendChild(tdNote);
            tbody.appendChild(tr);
        } else { // Mobile card view
            let card = document.createElement('div'); card.className = 'eventCard';
            if (isSystemEvent) card.style.backgroundColor = "#e3f2fd";
            let stateDisplayMob = lstateVal == "1" ? "<span class='badge bg-success'>RUNNING</span>" : "<span class='badge bg-danger'>STOPPED</span>";
            if (isSystemEvent) stateDisplayMob = lstateVal == "1" ? "<span class='badge bg-info text-dark'>SYSTEM UP</span>" : "<span class='badge bg-warning text-dark'>SYSTEM DOWN</span>";
            card.innerHTML = `<div><strong>${lasset}</strong> - ${stateDisplayMob} <small class='text-muted float-end'>${ldate} ${ltime}</small></div>` +
                             `<div>Event: ${levent} | Avail: ${Number(lavail).toFixed(1)}%</div>` +
                             (isSystemEvent ? "" : `<div><small>Run: ${durationStrToHHMMSS(runDurStr)} | Stop: ${durationStrToHHMMSS(stopDurStr)}</small></div>`) +
                             `<div class='mt-1'>Note: <span class='note'>${cleanNote(lnote)}</span> <button class='btn btn-sm btn-outline-primary py-0 px-1 float-end' onclick='showNoteModal("${ldate}","${ltime}","${lasset}","${escapedNote}")'>Edit</button></div>`;
            mobileDiv.appendChild(card);
        }
    }
    const ec = document.getElementById('eventCount');
    if (ec) ec.innerHTML = `Showing <b>${displayedCount}</b> event(s)`;
    
    if (!scrollInhibit && displayedCount > 0) { // Only scroll if there are events
        if (isMobile) { if (mobileDiv) mobileDiv.scrollTop = 0; }
        else { window.scrollTo({ top: 0, behavior: 'auto' }); }
    }
    scrollInhibit = false; // Reset after render
}

function toggleScrollInhibit(btn) {
  scrollInhibit = !scrollInhibit;
  if(btn) btn.innerText = scrollInhibit ? "Resume Scroll" : "Pause Scroll";
}

if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initializeEventPage); }
else { initializeEventPage(); }
)rawliteral");
  server.sendContent("</script>");
  server.sendContent("</body></html>");
  server.sendContent("");
}


String htmlAssetDetail(uint8_t idx) { // From your V21
  if (idx >= config.assetCount || idx >= MAX_ASSETS) return "Invalid Asset Index";
  String assetNameStr = String(config.assets[idx].name);
  String html = "<!DOCTYPE html><html><head><title>Asset Detail: " + assetNameStr + "</title>";
  html += "<meta name='viewport' content='width=device-width,initial-scale=1'><style>body{font-family:Roboto,Arial,sans-serif;margin:2em;background:#f3f7fa;} .card{background:#fff;padding:1.5em;border-radius:8px;box-shadow:0 2px 8px #0001;} h1{color:#1976d2;}</style></head><body><div class='card'>";
  html += "<h1>Asset Detail: " + assetNameStr + "</h1><p><strong>GPIO Pin:</strong> " + String(config.assets[idx].pin) + "</p>";
  html += "<p><a href='/'>Back to Dashboard</a></p><p><a href='/analytics?asset=" + urlEncode(assetNameStr) + "'>View Analytics</a></p></div></body></html>";
  return html;
}

// V21.ino (Continued - Chunk 9: Handler Functions)

void handleWiFiReconfigurePost() { // From your V21
  prefs.begin("assetmon", false); prefs.remove("ssid"); prefs.remove("pass"); prefs.end();
  Serial.println("WiFi credentials cleared. Restarting in AP mode.");
  String message = "<!DOCTYPE html><html><head><title>WiFi Reconfiguration</title><style>body{font-family:Arial,sans-serif;margin:20px;padding:15px;border:1px solid #ddd;border-radius:5px;text-align:center;} h2{color:green;}</style></head><body><h2>WiFi Credentials Cleared</h2><p>Device will now restart in Access Point mode ('AssetMonitor_Config'). Connect to this AP to set up new WiFi.</p><p>This page will attempt to redirect in 5 seconds, or you can manually go to the device's new IP (usually 192.168.4.1) once connected to the AP.</p><meta http-equiv='refresh' content='7;url=http://192.168.4.1/' /></body></html>"; // Added more info to message
  server.sendHeader("Connection", "close"); server.send(200, "text/html", message);
  delay(1500); // Slightly longer delay
  ESP.restart();
}

void handleConfigPost() {
  bool rebootNeeded = false; 

  // --- Asset Config ---
  if (server.hasArg("assetCount")) {
    uint8_t oldAssetCount = config.assetCount;
    // Use the ID "assetCountField" if that's what you used in htmlConfig, or "assetCount" if that's the name attribute
    config.assetCount = constrain(server.arg("assetCount").toInt(), 1, MAX_ASSETS); 
    if (config.assetCount != oldAssetCount) rebootNeeded = true;
    for (uint8_t i = 0; i < MAX_ASSETS; ++i) {
      if (i < config.assetCount) {
        if (server.hasArg("name"+String(i))) { 
            String newName = server.arg("name"+String(i));
            if(strcmp(config.assets[i].name, newName.c_str()) != 0) rebootNeeded = true;
            strncpy(config.assets[i].name, newName.c_str(), 31); config.assets[i].name[31] = '\0'; 
        }
        if (server.hasArg("pin"+String(i))) { 
            uint8_t newPin = server.arg("pin"+String(i)).toInt();
            if(config.assets[i].pin != newPin) rebootNeeded = true;
            config.assets[i].pin = newPin;
        }
      } else {
        if(strlen(config.assets[i].name) > 0) rebootNeeded = true;
        config.assets[i].name[0] = '\0'; config.assets[i].pin = 0;
      }
    }
  } else {
     server.send(400, "text/plain", "Bad Request: assetCount missing."); return;
  }

  // --- Operational Settings ---
  if (server.hasArg("maxEvents")) {
      uint16_t newVal = constrain(server.arg("maxEvents").toInt(), 100, 5000);
      if(config.maxEvents != newVal) rebootNeeded = true;
      config.maxEvents = newVal;
  }
  if (server.hasArg("tzOffset")) {
      int newVal = static_cast<int>(server.arg("tzOffset").toFloat() * 3600);
      if(config.tzOffset != newVal) rebootNeeded = true;
      config.tzOffset = newVal;
  }
  if (server.hasArg("longStopThreshold")) {
      int newVal = constrain(server.arg("longStopThreshold").toInt() * 60, 60, 1440 * 60);
      // if(config.longStopThresholdSec != newVal) rebootNeeded = true; // This alone might not need a reboot
      config.longStopThresholdSec = newVal;
  }
   if (server.hasArg("monitoringMode")) {
    int newMode = server.arg("monitoringMode").toInt();
    if (newMode != config.monitoringMode && (newMode == MONITORING_MODE_PARALLEL || newMode == MONITORING_MODE_SERIAL)) {
      if(config.monitoringMode != newMode) rebootNeeded = true;
      config.monitoringMode = newMode;
      g_systemStateInitialized = false; // Force re-evaluation of system state
    }
  }
  for (int i=0; i<5; ++i) {
    if(server.hasArg("reason"+String(i))) { 
        strncpy(config.downtimeReasons[i], server.arg("reason"+String(i)).c_str(), 31); 
        config.downtimeReasons[i][31] = '\0'; 
    }
  }

  // --- Parse Shift Configuration ---
  bool oldEnableShiftArchiving = config.enableShiftArchiving;
  config.enableShiftArchiving = server.hasArg("enableShiftArchiving");
  if (oldEnableShiftArchiving != config.enableShiftArchiving) rebootNeeded = true;

  if (config.enableShiftArchiving) {
    uint8_t oldNumShifts = config.numShifts;
    if (server.hasArg("numShifts")) {
      config.numShifts = constrain(server.arg("numShifts").toInt(), 1, MAX_CONFIGURABLE_SHIFTS);
    } else {
      config.numShifts = (oldNumShifts > 0 && oldNumShifts <=MAX_CONFIGURABLE_SHIFTS) ? oldNumShifts : 1; // Keep old if valid, else 1
    }
    if (oldNumShifts != config.numShifts) rebootNeeded = true;

    for (uint8_t i = 0; i < config.numShifts; ++i) {
      if (i < MAX_CONFIGURABLE_SHIFTS) {
        String argName = "shiftStartTime" + String(i);
        if (server.hasArg(argName)) {
          String newTime = server.arg(argName);
          if (newTime.length() == 5 && newTime.charAt(2) == ':') { // Basic HH:MM validation
            if (strcmp(config.shifts[i].startTime, newTime.c_str()) != 0) rebootNeeded = true;
            strncpy(config.shifts[i].startTime, newTime.c_str(), 5);
            config.shifts[i].startTime[5] = '\0';
          } else { // Invalid time format from form
            Serial.printf("Invalid time format received for %s: '%s'. Keeping old or default '00:00'.\n", argName.c_str(), newTime.c_str());
            if (strlen(config.shifts[i].startTime) == 0) strcpy(config.shifts[i].startTime,"00:00");
          }
        } else { // Shift time arg not found, but expected based on numShifts
           Serial.printf("Shift time arg %s not found for numShifts=%d. Ensuring default '00:00'.\n", argName.c_str(), config.numShifts);
           if (strlen(config.shifts[i].startTime) == 0) strcpy(config.shifts[i].startTime,"00:00");
        }
      }
    }
    for (uint8_t i = config.numShifts; i < MAX_CONFIGURABLE_SHIFTS; ++i) { // Clear unused shift slots
      if(strlen(config.shifts[i].startTime) > 0 && strcmp(config.shifts[i].startTime, "00:00") != 0) rebootNeeded = true;
      strcpy(config.shifts[i].startTime, "00:00");
    }
  } else { // Shift archiving disabled
    if (config.numShifts != 0) rebootNeeded = true; // If it was enabled and now disabled
    config.numShifts = 0;
    for (uint8_t i = 0; i < MAX_CONFIGURABLE_SHIFTS; ++i) {
      strcpy(config.shifts[i].startTime, "00:00");
    }
  }
  // --- End Parse Shift Configuration ---

  saveConfig();
  server.sendHeader("Location", "/config#saveNotice");
  server.send(303);
  delay(1000); // Give client time to process redirect
  ESP.restart(); // Reboot to apply all settings cleanly
}

void handleClearLog() { // Patched version
  SPIFFS.remove(LOG_FILENAME);
  Serial.println("Log cleared.");

  time_t now = time(nullptr);
  for (uint8_t i = 0; i < config.assetCount; ++i) {
    if (i < MAX_ASSETS) {
      assetStates[i].lastChangeTime = now;
      assetStates[i].sessionStart = now;
      assetStates[i].runningTime = 0; assetStates[i].stoppedTime = 0;
      assetStates[i].runCount = 0; assetStates[i].stopCount = 0;
      assetStates[i].lastEventTime = now;
      assetStates[i].lastRunDuration = 0; assetStates[i].lastStopDuration = 0;
      if (config.assets[i].pin > 0 && config.assets[i].pin < 40) {
          assetStates[i].lastState = digitalRead(config.assets[i].pin);
      } else {
          assetStates[i].lastState = true;
      }
    }
  }

  if (config.monitoringMode == MONITORING_MODE_SERIAL) {
    g_systemTotalRunningTimeSecs = 0;
    g_systemTotalStoppedTimeSecs = 0;
    g_systemStopCount = 0;
    g_systemLastStateChangeTime = now;
    g_systemStateInitialized = false; // Will force re-evaluation

    bool anyAssetCurrentlyStopped = false;
    g_serialSystemTriggerAssetName[0] = '\0';
    for (uint8_t k = 0; k < config.assetCount; ++k) {
      if (k < MAX_ASSETS) {
          bool assetEffectivelyStopped = assetStates[k].lastState;
          if (config.assets[k].pin == 0 || config.assets[k].pin >= 40) assetEffectivelyStopped = true;
          if (assetEffectivelyStopped) {
            anyAssetCurrentlyStopped = true;
            if (g_serialSystemTriggerAssetName[0] == '\0') {
                strncpy(g_serialSystemTriggerAssetName, config.assets[k].name, 31);
                g_serialSystemTriggerAssetName[31] = '\0';
            }
          }
      }
    }
    g_isSystemSerialDown = anyAssetCurrentlyStopped;
    g_systemStateInitialized = true;
    Serial.printf("Log cleared. Serial Mode: System state re-evaluated. Down: %s. Root Cause: %s\n",
                  g_isSystemSerialDown ? "Yes" : "No",
                  g_isSystemSerialDown ? g_serialSystemTriggerAssetName : "N/A");
    if (g_isSystemSerialDown) {
        logSystemEvent(false, now, g_serialSystemTriggerAssetName);
    } else {
        logSystemEvent(true, now, "System State After Log Clear - All Assets Up");
    }
  }
  server.sendHeader("Location", "/config"); // Or wherever you want to redirect
  server.send(303);
}

void handleExportLog() { // From your V21
  File f = SPIFFS.open(LOG_FILENAME, FILE_READ);
  if (!f || f.size() == 0) { server.send(404, "text/plain", "Log empty or not found."); if(f)f.close(); return; }
  time_t now_val = time(nullptr); struct tm *t_val = localtime(&now_val); char fn[64]; strftime(fn, sizeof(fn), "AssetLog-%Y%m%d-%H%M.csv", t_val);
  server.sendHeader("Content-Type", "text/csv"); server.sendHeader("Content-Disposition", String("attachment; filename=\"")+fn+"\"");
  server.setContentLength(f.size() + strlen("Date,Time,Asset,Event,State,Avail(%),Runtime(min),Downtime(min),MTBF(min),MTTR(min),Stops,RunDur,StopDur,Note\n")); // Approximate for progress bars
  server.send(200, "text/csv", "");
  server.sendContent("Date,Time,Asset,Event,State,Avail(%),Runtime(min),Downtime(min),MTBF(min),MTTR(min),Stops,RunDur,StopDur,Note\n");
  char buf[1025]; size_t br;
  while(f.available()){
    br=f.readBytes(buf,1024);
    if(br>0){ server.sendContent(buf, br); } // Send exact bytes read
  }
  f.close();
  // server.sendContent(""); // Final empty chunk to signify end if not using chunked encoding explicitly
  Serial.println("Log exported.");
}

void handleApiSummary() { // Patched version
  String json = "{";
  time_t now = time(nullptr);

  json += "\"monitoringMode\":" + String(config.monitoringMode) + ","; // Add current mode

  if (config.monitoringMode == MONITORING_MODE_SERIAL) {
    json += "\"systemStats\":{";
    json += "\"isDown\":" + String(g_isSystemSerialDown ? "true" : "false") + ",";
    json += "\"triggerAsset\":\"" + String(g_serialSystemTriggerAssetName) + "\",";

    unsigned long currentSystemRunTime = g_systemTotalRunningTimeSecs;
    unsigned long currentSystemStopTime = g_systemTotalStoppedTimeSecs;
    if (g_systemStateInitialized && g_systemLastStateChangeTime > 0) {
        unsigned long durationSinceLastChange = now - g_systemLastStateChangeTime;
        if (!g_isSystemSerialDown) { currentSystemRunTime += durationSinceLastChange; }
        else { currentSystemStopTime += durationSinceLastChange; }
    }

    float systemAvailability = (currentSystemRunTime + currentSystemStopTime) > 0
                               ? (100.0f * currentSystemRunTime / (currentSystemRunTime + currentSystemStopTime))
                               : (g_isSystemSerialDown ? 0.0f : 100.0f);
    json += "\"availability\":" + String(systemAvailability, 2) + ",";
    json += "\"totalRunningTimeSecs\":" + String(currentSystemRunTime) + ","; // For JS to convert to minutes/format
    json += "\"totalStoppedTimeSecs\":" + String(currentSystemStopTime) + ",";
    json += "\"stopCount\":" + String(g_systemStopCount) + ",";

    float systemMtbf_min = (g_systemStopCount > 0) ? ((float)currentSystemRunTime / 60.0f / g_systemStopCount) : (currentSystemRunTime > 0 ? (float)currentSystemRunTime / 60.0f : 0.0f) ;
    float systemMttr_min = (g_systemStopCount > 0) ? ((float)currentSystemStopTime / 60.0f / g_systemStopCount) : 0.0f;
    json += "\"mtbf_min\":" + String(systemMtbf_min, 2) + ","; // Key for JS dashboard
    json += "\"mttr_min\":" + String(systemMttr_min, 2);     // Key for JS dashboard
    json += "},";
  }

  json += "\"assets\":[";
  for (uint8_t i = 0; i < config.assetCount; ++i) {
    if (i >= MAX_ASSETS) continue;
    if (i > 0) json += ",";
    AssetState& as = assetStates[i];
    bool pin_s = true; // Assume stopped if pin invalid
    if (config.assets[i].pin > 0 && config.assets[i].pin < 40) {
        pin_s = digitalRead(config.assets[i].pin);
    }


    unsigned long runT_current = as.runningTime;
    unsigned long stopT_current = as.stoppedTime;
    if (as.lastChangeTime > 0) { // Add time since last event to current state's bucket
        unsigned long timeSinceLastChange = now - as.lastChangeTime;
        if (as.lastState == false) { // Was RUNNING (pin LOW)
            runT_current += timeSinceLastChange;
        } else { // Was STOPPED (pin HIGH)
            stopT_current += timeSinceLastChange;
        }
    }

    float avail = (runT_current + stopT_current) > 0 ? (100.0 * runT_current / (runT_current + stopT_current)) : (pin_s == false ? 100.0 : 0.0);
    float rt_m = runT_current / 60.0;
    float st_m = stopT_current / 60.0;
    float mtbf_calc = (as.stopCount > 0) ? rt_m / as.stopCount : (runT_current > 0 ? rt_m : 0.0); // MTBF in minutes
    float mttr_calc = (as.stopCount > 0) ? st_m / as.stopCount : 0.0;    // MTTR in minutes

    json += "{";
    json += "\"name\":\"" + String(config.assets[i].name) + "\",";
    json += "\"pin\":" + String(config.assets[i].pin) + ",";
    json += "\"state\":" + String(pin_s ? 0 : 1) + ",";
    json += "\"availability\":" + String(avail, 2) + ",";
    json += "\"total_runtime\":" + String(rt_m, 2) + ","; // Your dashboard JS expects this key
    json += "\"total_downtime\":" + String(st_m, 2) + ",";
    json += "\"mtbf\":" + String(mtbf_calc, 2) + ",";
    json += "\"mttr\":" + String(mttr_calc, 2) + ",";
    json += "\"stop_count\":" + String(as.stopCount);
    // Add last run/stop durations if your dashboard JS uses them
    json += ",\"lastRunDurationSecs\":" + String(as.lastRunDuration);
    json += ",\"lastStopDurationSecs\":" + String(as.lastStopDuration);
    json += "}";
  }
  json += "]}";
  server.send(200, "application/json", json);
}

// Replace your existing handleApiEvents with this one:
void handleApiEvents() {
  File f = SPIFFS.open(LOG_FILENAME, FILE_READ);
  String jsonOutput = "[";
  bool firstLine = true;

  if (f && f.size() > 0) {
    while (f.available()) {
      String line = f.readStringUntil('\n');
      line.trim();
      if (line.length() < 5) continue; // Skip empty or too short lines

      if (!firstLine) {
        jsonOutput += ",";
      }
      firstLine = false;

      jsonOutput += "[";
      int start = 0;
      int commaPos = 0;
      bool firstField = true;
      // Split the CSV line into fields and make each a JSON string
      while(start < line.length()) {
          commaPos = line.indexOf(',', start);
          if (commaPos == -1) { // Last field
              commaPos = line.length();
          }
          String field = line.substring(start, commaPos);
          // Escape quotes and backslashes within the field for JSON string validity
          String escapedField = "";
          for (unsigned int k=0; k < field.length(); k++) {
              char c = field.charAt(k);
              if (c == '"') escapedField += "\\\"";
              else if (c == '\\') escapedField += "\\\\";
              else escapedField += c;
          }

          if (!firstField) {
              jsonOutput += ",";
          }
          jsonOutput += "\"" + escapedField + "\"";
          firstField = false;
          start = commaPos + 1;
          if (start >= line.length() && commaPos == line.length()) break; // handles trailing empty field if line ends with comma
      }
      jsonOutput += "]";
    }
    f.close();
  }
  jsonOutput += "]";

  server.sendHeader("Cache-Control", "no-cache,no-store,must-revalidate");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "-1");
  server.send(200, "application/json", jsonOutput);
}

void handleApiConfig() { // From your V21
  String json="{"; json+="\"assetCount\":"+String(config.assetCount)+","; json+="\"maxEvents\":"+String(config.maxEvents)+","; json+="\"tzOffset\":"+String(config.tzOffset)+","; json+="\"assets\":[";
  for(uint8_t i=0;i<config.assetCount;++i){if(i>=MAX_ASSETS)continue;if(i>0)json+=",";json+="{";json+="\"name\":\""+String(config.assets[i].name)+"\",";json+="\"pin\":"+String(config.assets[i].pin)+"}";}
  json+="],\"downtimeReasons\":["; for(int i=0;i<5;++i){if(i>0)json+=",";json+="\""+String(config.downtimeReasons[i])+"\"";} json+="]";
  json+=",\"longStopThresholdSec\":"+String(config.longStopThresholdSec);
  json+=",\"monitoringMode\":"+String(config.monitoringMode); // Added monitoring mode
  json+="}"; server.send(200,"application/json",json);
}

void handleApiNote() { // From your V21
  if(server.method()==HTTP_POST&&server.hasArg("date")&&server.hasArg("time")&&server.hasArg("asset")){
    String d=server.arg("date"),t=server.arg("time"),a=server.arg("asset"),n=server.arg("note"),r=server.hasArg("reason")?server.arg("reason"):"";
    Serial.printf("API Note: D=%s,T=%s,A=%s,R=%s,N=%s\n",d.c_str(),t.c_str(),a.c_str(),r.c_str(),n.c_str());
    updateEventNote(d,t,a,n,r); server.sendHeader("Location","/events"); server.send(303); return;
  } server.send(400,"text/plain","Bad Request: Note params missing");
}

void updateEventNote(String date_str, String time_str, String assetName_str, String note_text_str, String reason_str) { // From your V21
  File f = SPIFFS.open(LOG_FILENAME, FILE_READ); if (!f) { Serial.println("updateEventNote: Fail read log."); return; }
  String tempLog = ""; bool updated = false;
  String combinedNote = "";
  // Ensure reason_str and note_text_str are properly handled if one is empty
  if (reason_str.length()>0 && reason_str != "Other") { // "Other" is just a selector, not part of the note
    combinedNote = reason_str;
    if (note_text_str.length()>0) {
        combinedNote += " - " + note_text_str;
    }
  } else {
    combinedNote = note_text_str;
  }
  combinedNote.replace(",", ";"); // Replace commas with semicolons to avoid breaking CSV
  combinedNote.replace("\n", " "); combinedNote.replace("\r", " ");

  String line;
  while (f.available()) {
    line = f.readStringUntil('\n');
    String trimmedLine = line; trimmedLine.trim();
    if (trimmedLine.length() < 5) { tempLog += line; if(f.available() || line.endsWith("\n")) tempLog+=""; else tempLog+="\n"; continue; }

    String parts[3]; int pIdx = 0; int lastC = -1;
    for(int k=0; k<3; ++k) {
        int nextC = trimmedLine.indexOf(',', lastC + 1);
        if (nextC == -1) { parts[pIdx++] = trimmedLine.substring(lastC + 1); break; }
        parts[pIdx++] = trimmedLine.substring(lastC + 1, nextC); lastC = nextC;
    }
    for(int k=pIdx; k<3; ++k) parts[k] = "";

    if (parts[0] == date_str && parts[1] == time_str && parts[2] == assetName_str) {
      int finalComma = -1; int commaCount = 0;
      for(int i=0; i<trimmedLine.length(); ++i){ if(trimmedLine.charAt(i)==','){commaCount++; if(commaCount==13){finalComma=i;break;}}}
      if (finalComma != -1) tempLog += trimmedLine.substring(0, finalComma + 1) + combinedNote + "\n";
      else tempLog += trimmedLine + "," + combinedNote + "\n"; // Should not happen if 13 commas is correct
      updated = true; Serial.println("Updated log line for: " + date_str + " " + time_str + " " + assetName_str);
    } else {
      tempLog += line;
      if (!line.endsWith("\n") && f.available()) tempLog += "\n";
    }
  }
  f.close();

  if (updated) {
    File f2 = SPIFFS.open(LOG_FILENAME, FILE_WRITE);
    if (!f2) { Serial.println("updateEventNote: Fail write log."); return; }
    f2.print(tempLog); f2.close(); Serial.println("Log rewritten with updated note.");
  } else Serial.println("Event for note update not found: " + date_str + " " + time_str + " " + assetName_str);
}

void handleNotFound() { server.send(404, "text/plain", "Not found"); } // From your V21
